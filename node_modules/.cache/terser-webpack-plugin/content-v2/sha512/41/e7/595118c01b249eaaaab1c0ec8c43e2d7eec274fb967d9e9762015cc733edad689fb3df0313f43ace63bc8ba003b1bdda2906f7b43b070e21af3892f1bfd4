{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{544:function(s,a,v){\"use strict\";v.r(a);var e=v(9),t=Object(e.a)({},(function(){var s=this,a=s.$createElement,v=s._self._c||a;return v(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[v(\"h2\",{attrs:{id:\"redis-的持久化\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis-的持久化\"}},[s._v(\"#\")]),s._v(\" Redis 的持久化\")]),s._v(\" \"),v(\"blockquote\",[v(\"p\",[s._v(\"首先我们要明确 Redis 为什么需要持久化？\")]),s._v(\" \"),v(\"p\",[s._v(\"Redis 持久化 并不是为了 \"),v(\"code\",[s._v(\"保证数据的完全性\")]),s._v(\",  保证完整性我们完全可以使用 \"),v(\"strong\",[s._v(\"关系型数据库\")]),s._v(\" 去存储数据。而是为了保证服务 出现故障 或 重启后快速的进行\"),v(\"strong\",[s._v(\"故障恢复\")])])]),s._v(\" \"),v(\"p\",[v(\"strong\",[s._v(\"持久化的机制\")])]),s._v(\" \"),v(\"p\",[s._v(\"Redis 提供了两种持久化方式 \"),v(\"code\",[s._v(\"RDB\")]),s._v(\" 和 \"),v(\"code\",[s._v(\"AOF\")])]),s._v(\" \"),v(\"h2\",{attrs:{id:\"rdb\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#rdb\"}},[s._v(\"#\")]),s._v(\" RDB\")]),s._v(\" \"),v(\"h3\",{attrs:{id:\"什么是rdb\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是rdb\"}},[s._v(\"#\")]),s._v(\" 什么是RDB?\")]),s._v(\" \"),v(\"blockquote\",[v(\"p\",[s._v(\"Redis DateBase, 是redis 默认的存储方式，是通过 \"),v(\"code\",[s._v(\"快照\")]),s._v(\" 完成的，即存储的是某一时刻的数据副本。 所生成的RDB文件是一个经过压缩的二进制文件\")])]),s._v(\" \"),v(\"p\",[v(\"strong\",[s._v(\"RDB 不关注存储的过程，只关注某一时刻的最终结果数据\")])]),s._v(\" \"),v(\"h3\",{attrs:{id:\"触发生成快照时间-或-方式\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#触发生成快照时间-或-方式\"}},[s._v(\"#\")]),s._v(\" 触发生成快照时间 或 方式\")]),s._v(\" \"),v(\"ol\",[v(\"li\",[s._v(\"符合自定义配置（自动间隔保存）的快照规则 （服务有默认配置，可以进行修改）\")]),s._v(\" \"),v(\"li\",[s._v(\"执行 \"),v(\"code\",[s._v(\"save\")]),s._v(\" 或 \"),v(\"code\",[s._v(\"bgsave\")]),s._v(\"命令\")]),s._v(\" \"),v(\"li\",[s._v(\"执行 \"),v(\"code\",[s._v(\"flushall\")]),s._v(\" 命令\")]),s._v(\" \"),v(\"li\",[s._v(\"执行主从服务操作 （仅第一次操作时）\")])]),s._v(\" \"),v(\"p\",[v(\"strong\",[s._v(\"配置自动间隔保存\")])]),s._v(\" \"),v(\"blockquote\",[v(\"p\",[s._v(\"当redis服务部署完成后就会有默认的生成快照的规则，\")]),s._v(\" \"),v(\"p\",[s._v(\"在 redis.conf 文件中进行配置: save 多少秒内 数据变了多少\")])]),s._v(\" \"),v(\"div\",{staticClass:\"language- extra-class\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[v(\"code\",[s._v('# 默认 save \"\" 是注释掉的\\nsave \"\" # 不使用RDB存储 不能主从\\n\\nsave 900 1          # 表示15分钟（900秒钟）内至少1个键被更改则进行快照。\\nsave 300 10         # 表示5分钟（300秒）内至少10个键被更改则进行快照。\\nsave 60 10000       # 表示1分钟内至少10000个键被更改则进行快照。\\n')])])]),v(\"p\",[v(\"strong\",[s._v(\"注：\")]),s._v(\" 在配置文件中 save 命令的配置 其实运行时 和 bgsave 是一样的效果，会由子进程操作\")]),s._v(\" \"),v(\"p\",[s._v(\"配置文件 Redis 服务启动会存储在 redisServer 中\")]),s._v(\" \"),v(\"img\",{attrs:{src:s.$withBase(\"/middleware/redis/image-20220301155917270.png\"),alt:\"foo\"}}),s._v(\" \"),v(\"div\",{staticClass:\"language-c extra-class\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-c\"}},[v(\"code\",[s._v(\"\\t\"),v(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"struct\")]),s._v(\" \"),v(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[s._v(\"redisServer\")]),s._v(\" \"),v(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"{\")]),s._v(\"     \\n    \"),v(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 记录保存的条件数组 设置的规则 都已数据形式存放\")]),s._v(\"\\n    \"),v(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"struct\")]),s._v(\" \"),v(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[s._v(\"saveparam\")]),s._v(\" \"),v(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"*\")]),s._v(\"saveparams\"),v(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"  \\n    \"),v(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 修改计数器 （从上一次成功执行完 save 操作后 执行的修改次数）   \")]),s._v(\"\\n    \"),v(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"long\")]),s._v(\" \"),v(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"long\")]),s._v(\" dirty\"),v(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"     \\n    \"),v(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 上一次执行保存的时间   \")]),s._v(\"\\n    time_t lastsave\"),v(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"   \\n\"),v(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"}\")]),v(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"\\n\")])])]),v(\"p\",[v(\"strong\",[v(\"code\",[s._v(\"save\")]),s._v(\" 和  \"),v(\"code\",[s._v(\"bgsave\")]),s._v(\" 的区别？\")])]),s._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[s._v(\"save：是一个同步保存操作,会堵塞redis服务进程,直到rdb文件创建完成为止, 进程堵塞期间不能处理任何命令请求\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[s._v(\"bgsave: 是一个异步操作，bgsave命令会派生出一个子进程，由子进程负责创建rdb文件，父进程继续处理 redis命令\")])])]),s._v(\" \"),v(\"h3\",{attrs:{id:\"生成-和-载入\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#生成-和-载入\"}},[s._v(\"#\")]),s._v(\" 生成 和 载入\")]),s._v(\" \"),v(\"h4\",{attrs:{id:\"生成\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#生成\"}},[s._v(\"#\")]),s._v(\" 生成\")]),s._v(\" \"),v(\"img\",{attrs:{src:s.$withBase(\"/middleware/redis/ECD69A54-4954-400A-8A41-62A1872D0215.png\"),alt:\"foo\"}}),s._v(\" \"),v(\"ol\",[v(\"li\",[s._v(\"客户端发送 bgsave 命令， Redis父进程首先判断是否有其他正在执行子进程（save | bgsave | bgrewriteaof）, 如果 有则：直接返回，无则：向下执行\")]),s._v(\" \"),v(\"li\",[s._v(\"父进程执行 fork 操作创建 子进程 （在 fork 期间 父进程会堵塞，不会执行来自客户端的任何命令）\")]),s._v(\" \"),v(\"li\",[s._v('父进程 fork后，bgsave命返回 \" Background saving started \" 信息并不再阻塞 Redis父进程，可以继续响应其他命令了。')]),s._v(\" \"),v(\"li\",[s._v(\"子进程，根据父进程内存快照生成临时RDB文件，完成后替换原来的 RDB 文件，同时发送信息给父进程表示RDB操作完成，父进程则更新统计信息\")])]),s._v(\" \"),v(\"h4\",{attrs:{id:\"载入\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#载入\"}},[s._v(\"#\")]),s._v(\" 载入\")]),s._v(\" \"),v(\"ol\",[v(\"li\",[s._v(\"服务器启动时自动加载检测是否有RDB文件存在\")]),s._v(\" \"),v(\"li\",[s._v(\"若有则自动再载入RDB文件，在载入期间处于阻塞状态\")]),s._v(\" \"),v(\"li\",[s._v(\"执行载入操作过，服务则可以对外响应请求\")])]),s._v(\" \"),v(\"p\",[v(\"strong\",[s._v(\"如果 Reids 开启了 AOF 会优先使用AOF 文件来还原数据库状态\")])]),s._v(\" \"),v(\"img\",{attrs:{src:s.$withBase(\"/middleware/redis/image-20220301161615211.png\"),alt:\"foo\"}}),s._v(\" \"),v(\"h3\",{attrs:{id:\"rdb的文件格式\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#rdb的文件格式\"}},[s._v(\"#\")]),s._v(\" RDB的文件格式\")]),s._v(\" \"),v(\"img\",{attrs:{src:s.$withBase(\"/middleware/redis/image-20220301194800936.png\"),alt:\"foo\"}}),s._v(\" \"),v(\"h2\",{attrs:{id:\"aof\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#aof\"}},[s._v(\"#\")]),s._v(\" AOF\")]),s._v(\" \"),v(\"blockquote\",[v(\"p\",[v(\"code\",[s._v(\"AOF (Append Only File)\")]),s._v(\" 持久化功能，默认是不开启的，\"),v(\"code\",[s._v(\"AOF\")]),s._v(\"持久化是通过保存 Redis所有的执行写入命令。 这样 Redis 重启后 只要按照顺序回访这些命令就会恢复到原始状态\")]),s._v(\" \"),v(\"p\",[v(\"strong\",[s._v(\"AOF\")]),s._v(\" 和 \"),v(\"strong\",[s._v(\"RDB\")]),s._v(\" 都开启了，redis重启的时候，也是优先通过 \"),v(\"strong\",[s._v(\"AOF\")]),s._v(\"进行数据恢复的，因为\"),v(\"strong\",[s._v(\"AOF\")]),s._v(\" 数据比较完整\")])]),s._v(\" \"),v(\"h3\",{attrs:{id:\"文件写入-和-保存\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#文件写入-和-保存\"}},[s._v(\"#\")]),s._v(\" 文件写入 和 保存\")]),s._v(\" \"),v(\"img\",{attrs:{src:s.$withBase(\"/middleware/redis/image-20220301214726480.png\"),alt:\"foo\"}}),s._v(\" \"),v(\"center\",[s._v(\"AOF持久化文件的生成\")]),s._v(\" \"),v(\"p\",[s._v(\"简单的可以理解为，每当client 端执行，非查询命令时，就会将其执行的命令，追加到 AOF 文件中\")]),s._v(\" \"),v(\"center\",[v(\"font\",{attrs:{color:\"red\"}},[s._v(\"具体流程\")])],1),s._v(\" \"),v(\"img\",{attrs:{src:s.$withBase(\"/middleware/redis/image-20220301220652881.png\"),alt:\"foo\"}}),s._v(\" \"),v(\"ol\",[v(\"li\",[s._v(\"命令追加：服务器每执行一次写命令都会以 协议格式 将执行的写命令追加到 \"),v(\"code\",[s._v(\"aof_buf\")]),s._v(\" 缓冲区的尾部\")]),s._v(\" \"),v(\"li\",[s._v(\"根据设定的规则，会进行异步将数据刷入磁盘中\")])]),s._v(\" \"),v(\"p\",[v(\"strong\",[s._v(\"AOF 的 save/fsync 策略\")])]),s._v(\" \"),v(\"p\",[s._v(\"有三种：\")]),s._v(\" \"),v(\"ul\",[v(\"li\",[s._v(\"always: 每次写入数据，就立即将数据刷入磁盘\")]),s._v(\" \"),v(\"li\",[s._v(\"everysec: 每隔1秒，将数据从 os cache 中写入磁盘 （每秒都是通过 fork 子进程进行写入）\")]),s._v(\" \"),v(\"li\",[s._v(\"no：仅写入 os cache, 不会写入磁盘，然后根据系统自身的策略来决定什么时候刷入磁盘\")])]),s._v(\" \"),v(\"p\",[s._v(\"Redis默认配置： \"),v(\"code\",[s._v(\"everysec\")])]),s._v(\" \"),v(\"h3\",{attrs:{id:\"数据恢复\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数据恢复\"}},[s._v(\"#\")]),s._v(\" 数据恢复\")]),s._v(\" \"),v(\"blockquote\",[v(\"p\",[s._v(\"AOF 恢复的过程相当简单，因为AOF文件里面包含了重建数据状态所需的所有写的命令，只需要服务根据顺序读入并重写执行一遍AOF文件里面所有的写命令即可\")])]),s._v(\" \"),v(\"img\",{attrs:{src:s.$withBase(\"/middleware/redis/image-20220301214447632.png\"),alt:\"foo\"}}),s._v(\" \"),v(\"h3\",{attrs:{id:\"文件重写\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#文件重写\"}},[s._v(\"#\")]),s._v(\" 文件重写\")]),s._v(\" \"),v(\"p\",[v(\"strong\",[s._v(\"为什么要重写\")])]),s._v(\" \"),v(\"p\",[s._v(\"随着命令的不断写入，数据会越来越多，文件会越来越大，所以需要瘦身，这样的好处在于，去除重复命令，较少数据，数据恢复时，熟读更快\")]),s._v(\" \"),v(\"p\",[v(\"strong\",[s._v(\"重写那些命令\")])]),s._v(\" \"),v(\"blockquote\",[v(\"p\",[s._v(\"将同一个key 的多条写入命令，重构成一条命令\")])]),s._v(\" \"),v(\"p\",[v(\"strong\",[s._v(\"重写的配置 和 启动方式\")])]),s._v(\" \"),v(\"ol\",[v(\"li\",[s._v(\"设置重写配置  \"),v(\"code\",[s._v(\"redis.conf\")]),s._v(\" 进行配置\")])]),s._v(\" \"),v(\"div\",{staticClass:\"language-shell extra-class\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-shell\"}},[v(\"code\",[v(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"# 表示当前aof文件大小超过上一次aof文件大小的百分之多少的时候会进行重写。如果之前没有重写过，以\")]),s._v(\"\\n启动时aof文件大小为准\\nauto-aof-rewrite-percentage \"),v(\"span\",{pre:!0,attrs:{class:\"token number\"}},[s._v(\"100\")]),s._v(\"\\n\\n\"),v(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"# 限制允许重写最小aof文件大小，也就是文件大小小于64mb的时候，不需要进行优化\")]),s._v(\"\\nauto-aof-rewrite-min-size 64mb\\n\\n\")])])]),v(\"ol\",{attrs:{start:\"2\"}},[v(\"li\",[s._v(\"也可以通过手动输入 \"),v(\"code\",[s._v(\"bgrewriteaof\")]),s._v(\" 命令 进行执行\")])]),s._v(\" \"),v(\"p\",[v(\"strong\",[s._v(\"具体执行流程\")])]),s._v(\" \"),v(\"img\",{attrs:{src:s.$withBase(\"/middleware/redis/45236039-F859-4992-94F9-6947F1524D09.png\"),alt:\"foo\"}}),s._v(\" \"),v(\"ol\",[v(\"li\",[s._v(\"AOF文件大小超过配置的最大值时，会触发AOF文件的 \"),v(\"code\",[s._v(\"rewrite\")]),s._v(\" 执行bgrewriteaof命令\")]),s._v(\" \"),v(\"li\",[s._v(\"redis进程会fork一个子进程，子进程会带有主进程的数据副本，来构建新的AOF文件\")]),s._v(\" \"),v(\"li\",[s._v(\"在rewrite期间，redis主进程会记录新的写入命令，并会开启AOF重写缓存\")]),s._v(\" \"),v(\"li\",[s._v(\"子进程完成AOF重写之后，会向主进程发送一个完成信号\")]),s._v(\" \"),v(\"li\",[s._v(\"主进程收到完成信号后，会将缓存池中的数据全部写入新的AOF文件中，对新的AOF文件改名，替换原有的AOF文件\")])]),s._v(\" \"),v(\"h2\",{attrs:{id:\"rdb-和-aof-两者的优缺点：\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#rdb-和-aof-两者的优缺点：\"}},[s._v(\"#\")]),s._v(\" RDB 和 AOF 两者的优缺点：\")]),s._v(\" \"),v(\"h4\",{attrs:{id:\"rdb-2\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#rdb-2\"}},[s._v(\"#\")]),s._v(\" RDB\")]),s._v(\" \"),v(\"ul\",[v(\"li\",[s._v(\"优点；\\n\"),v(\"ul\",[v(\"li\",[s._v(\"RDB 会生成多个数据文件，是更具某一时刻的redis数据，非常适合做冷备份\")]),s._v(\" \"),v(\"li\",[s._v(\"RDB 是二进制压缩文件，占用空间小，便于传输\")]),s._v(\" \"),v(\"li\",[s._v(\"RDB 对redis对外提供的读写服务, 影响非常小，可以让redis保持高性能，因为主进程只需要fork一个子进程，子进程来处理RDB持久化\")]),s._v(\" \"),v(\"li\",[s._v(\"RDB 存放的是一份数据文件，恢复时，直接加载到内存中即可 （恢复过程更快）\")])])]),s._v(\" \"),v(\"li\",[s._v(\"缺点:\\n\"),v(\"ul\",[v(\"li\",[s._v(\"RDB 因为是存储的某个时刻的数据，不能保证数据的完整性\")]),s._v(\" \"),v(\"li\",[s._v(\"如果 fork的子进程，数据文件特别大时，可能会导致暂停数毫秒或秒\")])])])]),s._v(\" \"),v(\"h4\",{attrs:{id:\"aof-2\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#aof-2\"}},[s._v(\"#\")]),s._v(\" AOF\")]),s._v(\" \"),v(\"ul\",[v(\"li\",[s._v(\"优点：\\n\"),v(\"ul\",[v(\"li\",[s._v(\"AOF 可以更好的保证数据的完整性，不丢失数据，一般AOF 会每隔1秒进行fsync操作，最多丢失一秒的数据\")]),s._v(\" \"),v(\"li\",[s._v(\"AOF 日志文件以 \"),v(\"code\",[s._v(\"append-only\")]),s._v(\" 模式写入，对磁盘寻址没有任何开销，写入性能高，文件不易破损，即使尾部破损，也容易恢复\")]),s._v(\" \"),v(\"li\",[s._v(\"AOF 文件过大，出现后台重写时，也不会用影响客户端的读写操作\")]),s._v(\" \"),v(\"li\",[s._v(\"AOF 日志文件是记录所有的命令，所有非常适合做灾难性的误删除的紧急恢复 （当不小心用了flushall命令时，只要后台rewrite 还没发生，就能通过AOF文件，将数据都回访回去）\")])])]),s._v(\" \"),v(\"li\",[s._v(\"缺点：\\n\"),v(\"ul\",[v(\"li\",[s._v(\"AOF日志文件 通常比 RDB数据快照要更大\")]),s._v(\" \"),v(\"li\",[s._v(\"AOF开启后的 写的QPS 会 比 RDB 的QPS低 （因为AOF每秒 fsync 一次，对性能的影响还是很大的）\")]),s._v(\" \"),v(\"li\",[s._v(\"做恢复时，会比较慢（需要回放和执行指令）\")]),s._v(\" \"),v(\"li\",[s._v(\"不方便做定期备份和 冷备份，需要手写脚本去恢复数据\")])])])])],1)}),[],!1,null,null,null);a.default=t.exports}}]);","extractedComments":[]}