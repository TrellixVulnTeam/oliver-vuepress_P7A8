(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{559:function(t,e,s){"use strict";s.r(e);var n=s(9),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("blockquote",[s("p",[s("code",[t._v("Sentinal(哨兵)")]),t._v("  是Redis的高可用解决方案：是由一个 或 多个 "),s("code",[t._v("Sentinal实例")]),t._v(" 组成的 Sentinel 系统")])]),t._v(" "),s("ul",[s("li",[t._v("一个哨兵哨兵实例，也可以保证服务，但是为了服务的健壮性，至少需要3个实例")]),t._v(" "),s("li",[t._v("哨兵 + Redis 主从的部署架构，是"),s("strong",[t._v("不保证数据零丢失")]),t._v("的，只能保证 Redis 集群的高可用性。")])]),t._v(" "),s("p",[s("strong",[t._v("作用")])]),t._v(" "),s("ul",[s("li",[t._v("集群监控：负责监控 Redis master 和 slave 进程是否正常工作。")])]),t._v(" "),s("ul",[s("li",[t._v("消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。")]),t._v(" "),s("li",[t._v("故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。")]),t._v(" "),s("li",[t._v("配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。")])]),t._v(" "),s("center",[s("b",[t._v("Sentinel案例图")])]),t._v(" "),s("img",{attrs:{src:t.$withBase("/middleware/redislearn/image-20220410103019964.png"),alt:"foo"}}),t._v(" "),s("h2",{attrs:{id:"启动-sentinel"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#启动-sentinel"}},[t._v("#")]),t._v(" 启动 Sentinel")]),t._v(" "),s("blockquote",[s("p",[s("code",[t._v("Redis-Sentinel")]),t._v("  是一台特殊的 Redis 服务器，支持的命令 和 普通的 Redis服务器不同\n并且 无需持久化机制")])]),t._v(" "),s("p",[s("strong",[t._v("启动命令")])]),t._v(" "),s("div",{staticClass:"language-C extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[t._v("redis"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("sentinel "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("path"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("to"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("your"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("sentinel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("conf\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 或")]),t._v("\n\nredis"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("server "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("path"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("to"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("your"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("sentinel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("conf "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("sentinel\n")])])]),s("p",[s("strong",[t._v("配置文件相关参数")])]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 哨兵sentinel监控的redis主节点的 ip port")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# sentinel monitor <master-name> <ip> <redis-port> <quorum>")]),t._v("\nsentinel monitor mymaster "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("127.0")]),t._v(".0.1 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6379")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# sentinel auth-pass <master-name> <password>")]),t._v("\nsentinel auth-pass mymaster MySUPER--secret-0123passw0rd\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒，改成3秒")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# sentinel down-after-milliseconds <master-name> <milliseconds>")]),t._v("\nsentinel down-after-milliseconds mymaster "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3000")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# sentinel parallel-syncs <master-name> <numslaves>")]),t._v("\nsentinel parallel-syncs mymaster "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 故障转移的超时时间 failover-timeout 可以用在以下这些方面：")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#1. 同一个sentinel对同一个master两次failover之间的间隔时间。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#3.当想要取消一个正在进行的failover所需要的时间。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 默认三分钟")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# sentinel failover-timeout <master-name> <milliseconds>")]),t._v("\nsentinel failover-timeout mymaster "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("180000")]),t._v("\n")])])]),s("h3",{attrs:{id:"启动步骤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#启动步骤"}},[t._v("#")]),t._v(" 启动步骤")]),t._v(" "),s("ol",[s("li",[t._v("初始化服务器")]),t._v(" "),s("li",[t._v("Redis服务器，设置专用的Sentinel 标识")]),t._v(" "),s("li",[t._v("初始化Sentinel 状态信息（即实例化SentinelState对象）")]),t._v(" "),s("li",[t._v("初始化 Sentinel 监控的主服务器列表")]),t._v(" "),s("li",[t._v("创建 主服务器的 网络连接")])]),t._v(" "),s("p",[s("strong",[t._v("1.初始化服务器")])]),t._v(" "),s("p",[t._v("由于 和 正常 Redis 功能有所不同，在初始化的过程中，会去除掉一些在 Sentinel 模式下不使用的功能")]),t._v(" "),s("p",[t._v("比如：载入 RDB 和 AOF 文件")]),t._v(" "),s("p",[s("strong",[t._v("2.Redis服务器，设置专用的Sentinel 标识")])]),t._v(" "),s("p",[t._v("1、设置 Sentinel 对应的 端口号 （sentinel.c/REDIS_SENTINEL_PORT常量）")]),t._v(" "),s("p",[t._v("2、设置对应的 Sentinel 命令表   （sentinel.c/sentinelcmds）")]),t._v(" "),s("p",[s("strong",[t._v("3.初始化Sentinel 状态信息（即实例化SentinelState对象）")])]),t._v(" "),s("p",[t._v("创建一个 SentinelState 结构，用于保存服务器中所有的 Sentinel 功能相关的数据信息")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("sentinelState")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("     \n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当前纪元,用于实现故障转移  ")]),t._v("\n\tuint64_t current_epoch"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   \n  \n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 保存了所有被这个sentinel 监视的主服务器 (key：服务器器名 value:sentinelRedisInstance (字典))")]),t._v("\n\tdict "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("masters"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    \n  \n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 是否进入了TILT 模式?    ")]),t._v("\n \t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" tilt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    \n  \n \t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 目前正在执行的脚本的数量  ")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" running_scripts"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   \n  \n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 进入TILT 模式的时间    ")]),t._v("\n\tmstime_t tilt_start_time"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   \n  \n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 最后一次执行时间处理器的时间   ")]),t._v("\n\tmstime_t previous_time"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n  \n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 一个FIFO 队列,包含了所有需要执行的用户脚本    ")]),t._v("\n\tlist "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("scripts_queue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" sentinel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[s("strong",[t._v("4.初始化 Sentinel 监控的主服务器列表")])]),t._v(" "),s("p",[t._v("SentinelState 中 使用一个 字典去存储 所有的主服务器信息列表")]),t._v(" "),s("ul",[s("li",[t._v("字典键：服务器名")]),t._v(" "),s("li",[t._v("字典值： sentinel.c/sentinelRedisInstance结构")])]),t._v(" "),s("img",{attrs:{src:t.$withBase("/middleware/redislearn/image-20220410111528575.png"),alt:"foo"}}),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("sentinelRedisInstance")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    \n  \n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 标识值,记录了实例的类型,以及该实例的当前状态  ")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" flags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   \n  \n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 实例的名字  如果没有配置的话 默认： 格式为ip:port ")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   \n  \n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 实例的运行ID     ")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("runid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   \n  \n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 配置纪元,用于实现故障转移  ")]),t._v("\n  uint64_t config_epoch"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("     \n  \n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 实例的地址   ")]),t._v("\n  sentinelAddr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("addr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   \n  \n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 实例无响应多少毫秒之后才会被判断为主观下线(subjectively down )   ")]),t._v("\n  mstime_t down_after_period"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  \n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 判断这个实例为客观下线所需的支持投票数量  ")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" quorum"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   \n  \n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在执行故障转移操作时,可以同时对新的主服务器进行同步的从服务器数量   ")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" parallel_syncs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n  \n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 刷新故障迁移状态的最大时限  ")]),t._v("\n  mstime_t failover_timeout"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    \n  \n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 从服务器列表")]),t._v("\n  dict "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("slaves"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" sentinelRedisInstance"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[s("strong",[t._v("5、创建 主服务器的 网络连接")])]),t._v(" "),s("p",[t._v("Sentinel 会与 需要被监控的主服务器建立网络连接，一共会创建两个连接")]),t._v(" "),s("ul",[s("li",[t._v("命令连接：专门用于向主服务器发送命令，并获取的信息\n"),s("ul",[s("li",[t._v("获取主服务器的信息")]),t._v(" "),s("li",[t._v("获取主服务器下的从服务器的信息")])])]),t._v(" "),s("li",[t._v("订阅连接：用于订阅主服务器 "),s("code",[t._v("__sentinel__:hello")]),t._v(" 频道\n"),s("ul",[s("li",[t._v("以及定时向 主、从服务器发送心跳信息")])])])]),t._v(" "),s("p",[s("strong",[t._v("问题1： 为什么有两个连接")])]),t._v(" "),s("ol",[s("li",[t._v("有一为了确保数据不会丢失，所以专门用一个订阅连接来接收频道信息")])]),t._v(" "),s("p",[s("strong",[t._v("问题2：Sentinel 实例之间为什么只有一个命令连接")])]),t._v(" "),s("p",[t._v("Sentinel 与 Sentinel 不需要进行订阅连接，Sentinel 通过订阅 主服务器 和 从服务器 就可以感知到对方")]),t._v(" "),s("h2",{attrs:{id:"sentinel-信息获取过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sentinel-信息获取过程"}},[t._v("#")]),t._v(" Sentinel 信息获取过程")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("Sentinel 默认每隔10秒 向 主服务器发送  info 消息 获取主服务器 和其从服务器的信息")])]),t._v(" "),s("li",[s("p",[t._v("与主服务器建立 命令连接 和 订阅连接")])]),t._v(" "),s("li",[s("p",[t._v("通过 获取都的从服务器 在向从服务器发送 info 消息 获取从服务器的信息 并建立连接")])]),t._v(" "),s("li",[s("p",[t._v("Sentinel每2s一次，向所有被监视的主服务器和从服务器所订阅的—sentinel—:hello频道上发送消息，消息中会携带Sentinel自身的信息和主服务器的信息。 【进行信息交互，判断自身和集群的信息是否一致】")])])]),t._v(" "),s("h2",{attrs:{id:"故障迁移"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#故障迁移"}},[t._v("#")]),t._v(" 故障迁移")]),t._v(" "),s("p",[s("strong",[t._v("主要分为一下3步")])]),t._v(" "),s("ol",[s("li",[t._v("判断是否下线")]),t._v(" "),s("li",[t._v("哨兵Leader选举")]),t._v(" "),s("li",[t._v("Leader进行故障转移\n"),s("ol",[s("li",[t._v("选举 Master 节点")]),t._v(" "),s("li",[t._v("进行故障转移")])])])]),t._v(" "),s("h3",{attrs:{id:"判断下线"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#判断下线"}},[t._v("#")]),t._v(" 判断下线")]),t._v(" "),s("blockquote",[s("p",[t._v("判断服务器是否下线的分为2个阶段  "),s("strong",[t._v("主观下线")]),t._v(" 、 "),s("strong",[t._v("客观下线")])])]),t._v(" "),s("p",[s("strong",[t._v("检测是如何发起的:")])]),t._v(" "),s("p",[t._v("Sentinel 每秒  向所有建立连接的服务器 发送一次 PING 命令进行心跳")]),t._v(" "),s("p",[t._v("返回：")]),t._v(" "),s("ul",[s("li",[t._v("+PONG")]),t._v(" "),s("li",[t._v("-LOADING")]),t._v(" "),s("li",[t._v("-MASTERDOWN")])]),t._v(" "),s("p",[t._v("其中一种，都任务服务正常，其他类型返回 或 指定时间内没有返回，则会认为无效")]),t._v(" "),s("p",[s("strong",[t._v("主观下线")])]),t._v(" "),s("p",[t._v("Sentinel 通过在配置文件中的 "),s("code",[t._v("down-after-milliseconds")]),t._v(" 选项，设置的多少毫秒内，没有返回有效的回复 或 超时，则认为是"),s("code",[t._v("主观下线")]),t._v(" ，会对 实例结构中 "),s("code",[t._v("flags")]),t._v(" 属性设置为 "),s("code",[t._v("SRI_S_DOWN")]),t._v(" 标识")]),t._v(" "),s("p",[t._v("问题1:  多个Sentinel设置的主观下线时长可能不同")]),t._v(" "),s("p",[t._v("一个设置了5S, 一个设置了8s。Sentinel 则会当 两个Sentinel 都符合条件后，才会认为是主观下线")]),t._v(" "),s("p",[t._v("即: 多个Sentinel 配置的短线时长 不一致时，只有两个都满足了，才认为是真的下线了")]),t._v(" "),s("p",[s("strong",[t._v("客观下线")])]),t._v(" "),s("blockquote",[s("p",[t._v("当服务器实例为 "),s("code",[t._v("主观下线")]),t._v(" ：Sentinel 会发送 "),s("code",[t._v("SENTINEL is-master-down-by-addr")]),t._v(" 命令，通知其他的哨兵进行判定该Redis是否已经下线，当判断下线的哨兵数 等于或超过 配置的数量，则认为是 "),s("code",[t._v("客观下线")]),t._v(" ， 会对 实例结构中 "),s("code",[t._v("flags")]),t._v(" 属性设置为 "),s("code",[t._v("SRI_O_DOWN")]),t._v(" 标识")])]),t._v(" "),s("p",[s("strong",[t._v("相关配置： "),s("code",[t._v("quorum=1")]),t._v("   quorum  符合投票哨兵的个数")])]),t._v(" "),s("h3",{attrs:{id:"哨兵-leader-选举"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#哨兵-leader-选举"}},[t._v("#")]),t._v(" 哨兵 Leader 选举")]),t._v(" "),s("blockquote",[s("p",[t._v("主服务器 判定为 客观下线时，就需要选举出一个 Leader ，由 Leader Sentinel 对下主服务器进行故障转移")]),t._v(" "),s("p",[t._v("哨兵的Leader 选举使用了 Raft协议来解决分布式一致性问题")])]),t._v(" "),s("p",[t._v("Sentinel 选举的过程：")]),t._v(" "),s("ol",[s("li",[t._v("某Sentinel认定master客观下线后，该Sentinel会先看看自己有没有投过票，如果自己已经投过票\n给其他Sentinel了，在一定时间内自己就不会成为Leader。")]),t._v(" "),s("li",[t._v("如果该Sentinel还没投过票，那么它就成为Candidate（候选人），并完成一下几件事情\n"),s("ul",[s("li",[t._v("更新故障转移状态为start")]),t._v(" "),s("li",[t._v("当前epoch加1，相当于进入一个新term，在Sentinel中epoch就是Raft协议中的term。")]),t._v(" "),s("li",[t._v("向其他节点发送 is-master-down-by-addr 命令请求投票。命令会带上自己的epoch。")]),t._v(" "),s("li",[t._v("给自己投一票（leader、leader_epoch）")])])]),t._v(" "),s("li",[t._v("当其它哨兵收到此命令时，可以同意或者拒绝它成为领导者；（通过判断epoch）")]),t._v(" "),s("li",[t._v("Candidate会不断的统计自己的票数，直到他发现认同他成为Leader的票数超过一半而且超过它配置的quorum，这时它就成为了Leader。")]),t._v(" "),s("li",[t._v("如果这个过程出现多个sentinel成为领导者(或者说票数相同时)，则会等待一段时间重新选举。")]),t._v(" "),s("li",[t._v("其他Sentinel等待Leader从slave选出master后，检测到新的master正常工作后，就会去掉客观下\n线的标识，进行故障转移操作")])]),t._v(" "),s("h3",{attrs:{id:"故障转移"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#故障转移"}},[t._v("#")]),t._v(" 故障转移")]),t._v(" "),s("p",[s("strong",[t._v("转移步骤")])]),t._v(" "),s("p",[t._v("1、在已下线主服务器下的 所有从服务器中，选出一个服务器")]),t._v(" "),s("p",[t._v("2、将 下线主服务器下的 所有从服务器，改为  复制 新的 主服务器")]),t._v(" "),s("p",[t._v("3、将已下线主服务器设置为新的主服务器的从服务器")]),t._v(" "),s("p",[s("strong",[t._v("主服务器的选择")])]),t._v(" "),s("ol",[s("li",[t._v("过滤掉已经 下线 或 断连 的从服务器")]),t._v(" "),s("li",[t._v("过滤掉 最近5秒内 没有回复过  Sentinel的从服务器")]),t._v(" "),s("li",[t._v("过滤掉 失效master  和 slave  断开时间超过了 "),s("code",[t._v("down-after-milliseconds")]),t._v(" 10秒 的服务 （即选出相对新的从服务）")]),t._v(" "),s("li",[t._v("对 slave 进行排序选出优先级高的\n"),s("ol",[s("li",[t._v("多个相同优先级的服务器，那么看 复制的偏移量，偏移量越靠后，优先级越高")]),t._v(" "),s("li",[t._v("多个优先级相同，偏移量相同，则看 run id ，优先选小的  （越小说明重启数越少）")])])])])],1)}),[],!1,null,null,null);e.default=a.exports}}]);