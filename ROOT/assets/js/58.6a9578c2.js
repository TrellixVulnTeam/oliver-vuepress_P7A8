(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{555:function(t,v,e){"use strict";e.r(v);var _=e(9),a=Object(_.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"缓存过期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存过期"}},[t._v("#")]),t._v(" 缓存过期")]),t._v(" "),e("blockquote",[e("p",[t._v("Redis 作为缓存使用，不断增加 Key ，则会出现 达到物理内存峰值后性能急剧下降，甚至奔溃。这就需要我们进行合理的分配 Redis 使用的 最大内存大小")]),t._v(" "),e("p",[t._v("Redis 通过  "),e("code",[t._v("maxmemory")]),t._v("  参数进行配置， 默认为：0   不进行限制")])]),t._v(" "),e("p",[e("strong",[t._v("建议")]),t._v(" 设置成 物理内存的 "),e("code",[t._v("3/4")]),t._v("  比较合适\n"),e("strong",[t._v("注")]),t._v(" 当 设置 "),e("code",[t._v("maxmemory")]),t._v(" 大小后：当内存趋近 "),e("code",[t._v("maxmemory")]),t._v(" 时，通过缓存淘汰策略，从内存中删除对象")]),t._v(" "),e("p",[t._v("具体配置操作：")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("# 在 redis"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("conf 中进行设置\nmaxmemory "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),t._v("mb\n")])])]),e("p",[e("strong",[t._v("设置缓存过期时间的方式")])]),t._v(" "),e("ul",[e("li",[e("code",[t._v("EXPIRE<key><ttl>")]),t._v(" 命令用于将键key的生存时间设置为ttl秒。")]),t._v(" "),e("li",[e("code",[t._v("PEXPIRE<key><ttl>")]),t._v(" 命令用于将键key的生存时间设置为ttl毫秒。")]),t._v(" "),e("li",[e("code",[t._v("EXPIREAT<key><timestamp>")]),t._v(" 命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。")]),t._v(" "),e("li",[e("code",[t._v("PEXPIREAT<key><timestamp>")]),t._v(" 命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。")])]),t._v(" "),e("p",[e("strong",[t._v("EXPIRE、PEXPIRE和EXPIREAT三个命令都会转换成PEXPIREAT")])]),t._v(" "),e("h3",{attrs:{id:"过期时间的保存方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#过期时间的保存方式"}},[t._v("#")]),t._v(" 过期时间的保存方式")]),t._v(" "),e("p",[e("strong",[t._v("RedisDb")]),t._v("  结构中使用  "),e("code",[t._v("expries")]),t._v(" 字典（保存 过期对象）")]),t._v(" "),e("p",[t._v("键：设置过期对象的指针")]),t._v(" "),e("p",[t._v("值：long型的过期时间 （一个毫秒精度的UNIX时间戳）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("struct redisDb{\n  dict *expires; 过期字典,保存着键的过期时间 \n} redisDb;\n")])])]),e("img",{attrs:{src:t.$withBase("/middleware/redislearn/redis缓存过期时间数据结构.png"),alt:"foo"}}),t._v(" "),e("h3",{attrs:{id:"过期键的的判定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#过期键的的判定"}},[t._v("#")]),t._v(" 过期键的的判定")]),t._v(" "),e("ul",[e("li",[t._v("Key 是否在 过期字典中")]),t._v(" "),e("li",[t._v("key设置的 时间戳 是否大于 当前时间，大于则未过期")])]),t._v(" "),e("h3",{attrs:{id:"过期删除策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#过期删除策略"}},[t._v("#")]),t._v(" 过期删除策略")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("过期策略")]),t._v(" "),e("th",[t._v("分类")]),t._v(" "),e("th",[t._v("原理")]),t._v(" "),e("th",[t._v("优点")]),t._v(" "),e("th",[t._v("缺点")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("定时删除")]),t._v(" "),e("td",[t._v("主动删除型策略")]),t._v(" "),e("td",[t._v("当设置完key的过期时间，同时设置一个定时器来进行对 key的过期删除操作")]),t._v(" "),e("td",[t._v("对内存最友好：过期key，立马被释放，不占用内存")]),t._v(" "),e("td",[t._v("对CPU不友好：在过期key 过多时，过多的定时器会占用CPU大量的资源")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("惰性删除")]),t._v(" "),e("td",[t._v("被动删除型策略")]),t._v(" "),e("td",[t._v("对过期key不主动删除，只有 key被访问时，会进行判断是否过期，过期则删除key")]),t._v(" "),e("td",[t._v("对CPU最友好： 只有在取出key 的时候才进行检查，其他时候就算过期也不做任何操作")]),t._v(" "),e("td",[t._v("对内存不友好：如果大量过期key, 长时间不被访问，将一直占用内存空间，造成空间浪费  也算是一种 "),e("code",[t._v("内存泄漏")])])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("定期删除")]),t._v(" "),e("td",[t._v("主动删除型策略")]),t._v(" "),e("td",[t._v("每隔一段时间，进行检查并删除过期的key, 至于删除多少key,检查多少库 由算法决定")]),t._v(" "),e("td",[t._v("定期删除，限制了删除的时长和频率减少对CPU的影响，也又有定期删除的减少了 key过期造成的内存浪费")]),t._v(" "),e("td",[t._v("难以：确定删除操作执行的时长和频率:")])])])]),t._v(" "),e("h2",{attrs:{id:"内存淘汰策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存淘汰策略"}},[t._v("#")]),t._v(" 内存淘汰策略")]),t._v(" "),e("h3",{attrs:{id:"配置内存淘汰策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#配置内存淘汰策略"}},[t._v("#")]),t._v(" 配置内存淘汰策略")]),t._v(" "),e("blockquote",[e("p",[t._v("通过 redis.conf 进行配置 主动删除策略，默认是 "),e("code",[t._v("no-enviction")]),t._v(" (不删除)")])]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("maxmemory"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("policy allkeys"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("lru\n")])])]),e("p",[e("strong",[t._v("注")]),t._v("  默认的内存淘汰策略： "),e("code",[t._v("noenviction")])]),t._v(" "),e("p",[e("strong",[t._v("淘汰策略类型")])]),t._v(" "),e("ul",[e("li",[t._v("noenviction: 禁止内存淘汰，默认设置")]),t._v(" "),e("li",[t._v("LRU\n"),e("ul",[e("li",[t._v("volatile-lru ： 从已设置过期时间的 数据集 中挑选最近最少使用的数据淘汰")]),t._v(" "),e("li",[t._v("allkeys-lru： 从所有的 数据集 中挑选最近最少使用的数据淘汰")])])]),t._v(" "),e("li",[t._v("LFU\n"),e("ul",[e("li",[t._v("volatile-lfu： 从配置了过期时间的键中删除使用频率最少的键")]),t._v(" "),e("li",[t._v("allkeys-lfu： 从所有的键中删除使用频率最少的键")])])]),t._v(" "),e("li",[t._v("random\n"),e("ul",[e("li",[t._v("volatile-random： 从已设置过期时间的 数据集 中 随机选择数据淘汰")]),t._v(" "),e("li",[t._v("allkeys-random： 从所有的 数据集 中 随机选择数据淘汰")])])]),t._v(" "),e("li",[t._v("ttl\n"),e("ul",[e("li",[t._v("volatile-ttl： 从已设置过期的 数据集 中 挑选将要过期的数据淘汰")])])])]),t._v(" "),e("h3",{attrs:{id:"lru"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lru"}},[t._v("#")]),t._v(" LRU")]),t._v(" "),e("blockquote",[e("p",[t._v("LRU (Least recently used) 最近最少使用，算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”")])]),t._v(" "),e("h3",{attrs:{id:"lfu"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lfu"}},[t._v("#")]),t._v(" LFU")]),t._v(" "),e("blockquote",[e("p",[t._v("LFU (Least frequently used) 最不经常使用，如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。")])]),t._v(" "),e("ul",[e("li",[t._v("LRU:\n"),e("ul",[e("li",[t._v("即长时间没有读取，或写，则会被移到链表尾部，进行删除")])])]),t._v(" "),e("li",[t._v("LFU\n"),e("ul",[e("li",[t._v("即 一段时间内使用频次最少的，进行删除，类似于范围区间内统计次数")])])])])])}),[],!1,null,null,null);v.default=a.exports}}]);