(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{544:function(v,_,e){"use strict";e.r(_);var r=e(9),t=Object(r.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("blockquote",[e("p",[v._v("Redis 服务器是一个 "),e("code",[v._v("事件驱动程序")]),v._v(" 主要分为两类事件 "),e("code",[v._v("文件事件")]),v._v("、"),e("code",[v._v("时间事件")])])]),v._v(" "),e("ul",[e("li",[v._v("文件事件：是 服务器 对 套接字（socket）操作的抽象，即 客户端 通过 套接字 和 服务器通信 产生相应的文件事件")]),v._v(" "),e("li",[v._v("时间事件：需要在给定的时间点执行")])]),v._v(" "),e("h3",{attrs:{id:"文件事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文件事件"}},[v._v("#")]),v._v(" 文件事件")]),v._v(" "),e("blockquote",[e("p",[v._v("Redis 基于 "),e("code",[v._v("Reactor")]),v._v(" 模式开发了自己的网络事件处理器 被称为： 文件事件处理器")]),v._v(" "),e("p",[v._v("文件事件处理器以单线程方式运行， 使用I/O多路复用程序来监听多个套接字,文件事件处理器既实现了高性能的网络通信模型,又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接")])]),v._v(" "),e("h4",{attrs:{id:"文件事件处理器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文件事件处理器"}},[v._v("#")]),v._v(" 文件事件处理器")]),v._v(" "),e("blockquote",[e("p",[v._v("文件事件处理器的四个组成部分,它们分别是套接字、I/O多路复用程序、文件事件分派器(dispatcher),以及事件处理器。")])]),v._v(" "),e("img",{attrs:{src:v.$withBase("/middleware/redislearn/redis事件处理器.png"),alt:"foo"}}),v._v(" "),e("ul",[e("li",[e("code",[v._v("套接字")]),v._v("：socket请求执行每次连接应答(accept)、写入、读取、关闭等操作时，都对产生对应的事件给服务器")]),v._v(" "),e("li",[e("code",[v._v("I/O多路复用程序")]),v._v(":\n"),e("ul",[e("li",[v._v("会将所有产生的事件，放到 "),e("strong",[v._v("队列中")]),v._v("，以 "),e("strong",[v._v("有序")]),v._v("、"),e("strong",[v._v("同步")]),v._v(" 的方式, 向 "),e("strong",[v._v("文件事件分派器")]),v._v(" 传输 套接字")]),v._v(" "),e("li",[v._v("I/O 多路服务程序：Redis 将常见的 select、epoll、evport和kqueue  实现方式都实现了，程序会在编译时自动选择系统中性能最高的I/O多路复用函数库来作为Redis的I/O多路复用程序的底层实现")])])]),v._v(" "),e("li",[v._v("文件事件分派器： 会根据 具体的事件 分配给 具体的事件处理器")]),v._v(" "),e("li",[v._v("文件事件处理器:\n"),e("ul",[e("li",[v._v("连接应答处理器")]),v._v(" "),e("li",[v._v("命令请求处理器")]),v._v(" "),e("li",[v._v("命令回复处理器")]),v._v(" "),e("li",[v._v("复制处理器")])])])]),v._v(" "),e("h3",{attrs:{id:"时间事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#时间事件"}},[v._v("#")]),v._v(" 时间事件")]),v._v(" "),e("p",[e("strong",[v._v("分为两大类：")])]),v._v(" "),e("ul",[e("li",[v._v("定时事件： 让一段程序在指定的时间之后执行一次")]),v._v(" "),e("li",[v._v("周期性事件： 让一段程序每隔指定时间就执行一次")])]),v._v(" "),e("p",[e("strong",[v._v("目前版本的Redis只使用周期性事件， 没有 定时事件")])]),v._v(" "),e("p",[e("strong",[v._v("一个时间事情的组成")])]),v._v(" "),e("ul",[e("li",[v._v("id:  服务器为时间事件创建的全局唯一ID")]),v._v(" "),e("li",[v._v("when:  毫秒精度的UNIX时间戳,记录了时间事件的到达(arrive)时间")]),v._v(" "),e("li",[v._v("timeProc:  时间事件处理器（一个函数），当时间到达时，用来处理事件的")])]),v._v(" "),e("p",[e("strong",[v._v("如何判断/生成周期性任务")])]),v._v(" "),e("p",[v._v("定时事件 还是 周期性事件 是通过 事件处理器的 返回值 确定的")]),v._v(" "),e("ul",[e("li",[v._v("返回："),e("code",[v._v("AE_NOMORE")]),v._v("  （定时事件）")]),v._v(" "),e("li",[v._v("返回：非 "),e("code",[v._v("AE_NOMORE")]),v._v("  (周期性事件，并更新 时间事件的 when属性)")])]),v._v(" "),e("h4",{attrs:{id:"具体实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#具体实现"}},[v._v("#")]),v._v(" 具体实现")]),v._v(" "),e("img",{attrs:{src:v.$withBase("/middleware/redislearn/redis时间事件.png"),alt:"foo"}}),v._v(" "),e("p",[v._v("Redis 将所有的 时间事件 存放在一个 "),e("strong",[v._v("无序链表")]),v._v("  中 （此无序是指，不更具id排序，更具when 大小排序）。")]),v._v(" "),e("p",[v._v("每当创建 时间事件时，会插入到 链表头部")]),v._v(" "),e("h4",{attrs:{id:"servercron函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#servercron函数"}},[v._v("#")]),v._v(" serverCron函数")]),v._v(" "),e("blockquote",[e("p",[v._v("时间事件 主要的应用是在 Redis服务器 需要定期对自身的资源和状态进行检查和调整,从而确保服务器可以长期、稳定地运行。\n这些定期操作由redis.c中的 "),e("code",[v._v("serverCron")]),v._v("函数负责执行,它的主要工作包括:")])]),v._v(" "),e("ol",[e("li",[v._v("更新服务器的各类统计信息,比如时间、内存占用、数据库占用情况等")]),v._v(" "),e("li",[v._v("清理数据库中的过期键值对")]),v._v(" "),e("li",[v._v("关闭和清理连接失效的客户端")]),v._v(" "),e("li",[v._v("尝试进行AOF或RDB持久化操作")]),v._v(" "),e("li",[v._v("如果服务器是主服务器,那么对从服务器进行定期同步。")]),v._v(" "),e("li",[v._v("如果处于集群模式,对集群进行定期同步和连接测试")])]),v._v(" "),e("p",[v._v("Redis2.6版本：默认 "),e("code",[v._v("serverCron")]),v._v("函数 每秒运行 10次，平均 每间隔 100毫秒运行一次")]),v._v(" "),e("p",[v._v("Redis2.8开始 可以进行配置修改 serverCron在一秒内执行的次数 ， 在redis/conf中可以配置")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("hz 100\n")])])]),e("h3",{attrs:{id:"事件的调度与执行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件的调度与执行"}},[v._v("#")]),v._v(" 事件的调度与执行")]),v._v(" "),e("blockquote",[e("p",[v._v("服务器中同时存在文件事件和时间事件两种事件类型,所以服务器必须对这两种事件进行调度")])]),v._v(" "),e("img",{attrs:{src:v.$withBase("/middleware/redislearn/redis事件调度流程.png"),alt:"foo"}}),v._v(" "),e("ol",[e("li",[v._v("文件事件是随机出现的，处理完一次文件事件后，任为有时间事件到达，则会接着执行文件事件")]),v._v(" "),e("li",[v._v("因为 时间事件 在文件事件之后执行，事件之间不会抢占，所以时间事件的处理时间，通常比设定的到达时间晚一些")])])])}),[],!1,null,null,null);_.default=t.exports}}]);