(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{515:function(v,_,a){"use strict";a.r(_);var t=a(9),i=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h2",{attrs:{id:"什么是面向对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是面向对象"}},[v._v("#")]),v._v(" 什么是面向对象")]),v._v(" "),a("h3",{attrs:{id:"什么是面向过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是面向过程"}},[v._v("#")]),v._v(" 什么是面向过程 ?")]),v._v(" "),a("blockquote",[a("p",[v._v("自顶而下的编程模式")])]),v._v(" "),a("p",[v._v("就是说：将一个功能点 一步接一步的调用函数实现，并没后做相对应的抽象")]),v._v(" "),a("h3",{attrs:{id:"什么是面向对象？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是面向对象？"}},[v._v("#")]),v._v(" 什么是面向对象？")]),v._v(" "),a("blockquote",[a("p",[v._v("将事务高度抽象化的编程模式")])]),v._v(" "),a("p",[v._v("就是说：将一个功能点中的每个步进行相对应的抽象形成不同的对象，通过不同对象之间的调用，或组合来完成功能")]),v._v(" "),a("h3",{attrs:{id:"面向对象的三大特征"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象的三大特征"}},[v._v("#")]),v._v(" 面向对象的三大特征")]),v._v(" "),a("ul",[a("li",[v._v("封装")]),v._v(" "),a("li",[v._v("继承")]),v._v(" "),a("li",[v._v("多态")])]),v._v(" "),a("blockquote",[a("p",[v._v("具体含义可自行百度")])]),v._v(" "),a("h3",{attrs:{id:"面向对象的五大基本原则："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象的五大基本原则："}},[v._v("#")]),v._v(" 面向对象的五大基本原则：")]),v._v(" "),a("h4",{attrs:{id:"单一职责原则（single-responsibility-principle）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则（single-responsibility-principle）"}},[v._v("#")]),v._v(" 单一职责原则（Single-Responsibility Principle）")]),v._v(" "),a("ul",[a("li",[v._v("核心思想：一个类，最好只做一件事情  并且 仅有一个引起它变化的原因")]),v._v(" "),a("li",[v._v("简单的理解 ：一个对象的功能要单一，可以理解为 低耦合、高内聚")])]),v._v(" "),a("h4",{attrs:{id:"开放封闭原则（open-closed-principle）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开放封闭原则（open-closed-principle）"}},[v._v("#")]),v._v(" 开放封闭原则（Open-Closed principle）")]),v._v(" "),a("ul",[a("li",[v._v("核心思想: 软件实体应该是可扩展，而不可修改的\n"),a("ul",[a("li",[v._v("对于扩展是开放的")]),v._v(" "),a("li",[v._v("对于修改是封闭的")])])]),v._v(" "),a("li",[v._v("扩展开放：\n"),a("ul",[a("li",[v._v("因为需求总是在变化的，我们可以对现有代码进行扩展，在变化时我们可以通过继承或多态机制，来改变固有行为，实现新的扩展方法")])])]),v._v(" "),a("li",[v._v("修改封闭：\n"),a("ul",[a("li",[v._v("类一但时设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。")]),v._v(" "),a("li",[v._v("核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的")])])])]),v._v(" "),a("h4",{attrs:{id:"liskov替换原则（liskov-substitution-principle）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#liskov替换原则（liskov-substitution-principle）"}},[v._v("#")]),v._v(" Liskov替换原则（Liskov-Substitution Principle）")]),v._v(" "),a("ul",[a("li",[v._v("子类型必须能够替换掉它们的父类型。简单地说，这是因为子类型继承了父类，所以子类可以以父类的身份出现。")])]),v._v(" "),a("h4",{attrs:{id:"依赖倒置原则（dependecy-inversion-principle）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒置原则（dependecy-inversion-principle）"}},[v._v("#")]),v._v(" 依赖倒置原则（Dependecy-Inversion Principle）")]),v._v(" "),a("ul",[a("li",[v._v("核心思想：抽象不应该依赖写，细节应该依赖于抽象")]),v._v(" "),a("li",[v._v("简单的理解：我们要针对接口编程，而不要针对实现编程\n"),a("ul",[a("li",[v._v("高层模块不应该依赖底层模块，两个都应该依赖抽象\n"),a("ul",[a("li",[v._v("缺点：高度模块太依赖底层模块，耦合太紧密。底层模块发送变化会影响到高层模块")])])]),v._v(" "),a("li",[v._v("抽象不用管依赖具体（细节），具体 （细节） 应该依赖抽象\n"),a("ul",[a("li",[v._v("有点：修改底层不会影响到高层模块，减小了他们之间的耦合度，增强系统的稳定性")])])])])])]),v._v(" "),a("h4",{attrs:{id:"接口隔离原则（interface-segregation-principle）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则（interface-segregation-principle）"}},[v._v("#")]),v._v(" 接口隔离原则（Interface-Segregation Principle）")]),v._v(" "),a("ul",[a("li",[v._v("核心思想：使用多个小的专门的接口，而不要使用一个大的总接口")]),v._v(" "),a("li",[v._v("原则体现：接口应该是内聚的，应该避免 "),a("code",[v._v("胖")]),v._v("接口。胖接口可能有很多我们用不到的方法，不要强迫依赖不用的方法，这是一种接口污染")]),v._v(" "),a("li",[v._v("通俗的理解：不要强迫客户使用他们不想用的商品")]),v._v(" "),a("li",[v._v("解决方案：\n"),a("ul",[a("li",[v._v("委任分离：通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销")]),v._v(" "),a("li",[v._v("多重继承分离接口：通过集成多个单一小接口，来解决继承的大接口")])])])]),v._v(" "),a("h2",{attrs:{id:"封装、继承、多态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#封装、继承、多态"}},[v._v("#")]),v._v(" 封装、继承、多态")]),v._v(" "),a("h3",{attrs:{id:"什么是多态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是多态"}},[v._v("#")]),v._v(" 什么是多态")]),v._v(" "),a("blockquote",[a("p",[v._v("同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果")]),v._v(" "),a("p",[v._v("多态应该是一种运行期的状态")])]),v._v(" "),a("p",[v._v("多态的必要条件：")]),v._v(" "),a("ul",[a("li",[v._v("类要有继承 或者接口实现")]),v._v(" "),a("li",[v._v("子类要重写父类的方法")]),v._v(" "),a("li",[v._v("父类的引用执行子类的对象")])]),v._v(" "),a("h2",{attrs:{id:"方法重写-与-重载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法重写-与-重载"}},[v._v("#")]),v._v(" 方法重写 与 重载")]),v._v(" "),a("h3",{attrs:{id:"重写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重写"}},[v._v("#")]),v._v(" 重写")]),v._v(" "),a("br"),v._v(" "),a("img",{attrs:{src:v.$withBase("/java/oop/overriding.png"),alt:"foo"}}),v._v(" "),a("h3",{attrs:{id:"重载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重载"}},[v._v("#")]),v._v(" 重载")]),v._v(" "),a("br"),v._v(" "),a("img",{attrs:{src:v.$withBase("/java/oop/overloading.png"),alt:"foo"}}),v._v(" "),a("blockquote",[a("p",[v._v("其他相关：")]),v._v(" "),a("p",[v._v("https://blog.csdn.net/carson_ho/article/details/81502540")]),v._v(" "),a("p",[v._v("https://www.cnblogs.com/constantwang/p/11141566.html")])]),v._v(" "),a("h3",{attrs:{id:"java的继承-与-实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java的继承-与-实现"}},[v._v("#")]),v._v(" Java的继承 与 实现")]),v._v(" "),a("blockquote",[a("p",[v._v("Java 中")]),v._v(" "),a("p",[v._v("继承的根本原因是要 "),a("code",[v._v("复用")])]),v._v(" "),a("p",[v._v("实现的根本原因是要 "),a("code",[v._v("定义一个标准")])])]),v._v(" "),a("p",[v._v("继承使用 "),a("code",[v._v("extends")]),v._v(" 关键字实现")]),v._v(" "),a("p",[v._v("实现使用 "),a("code",[v._v("implemenets")]),v._v(" 实现")]),v._v(" "),a("h2",{attrs:{id:"java的构造函数-与-默认构造函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java的构造函数-与-默认构造函数"}},[v._v("#")]),v._v(" Java的构造函数 与 默认构造函数")]),v._v(" "),a("p",[v._v("构造函数：主要用来在创建对象时初始化对象，一般会跟new 运算符一起使用，给对象成员变量赋初始值")]),v._v(" "),a("p",[v._v("构造函数的特点：")]),v._v(" "),a("ul",[a("li",[v._v("构造函数的 "),a("em",[v._v("名称必须与类名相同")]),v._v("， 并且大小写铭感")]),v._v(" "),a("li",[v._v("构造函数 没有返回值、也不能用 void修饰 （如果构造函数 加上了返回值，就会变为普通函数）")]),v._v(" "),a("li",[v._v("一个类可以用有多个构造方法，如果没有定义构造方法，编译器会自动创建一个无参数且方法体为空的默认构造函数")]),v._v(" "),a("li",[v._v("构造方法可以进行 "),a("em",[v._v("重载")])])]),v._v(" "),a("p",[v._v("显示声明的无惨构造函数 和 默认构造函数的区别")]),v._v(" "),a("ul",[a("li",[v._v("创建主体不同：\n"),a("ul",[a("li",[v._v("无惨构造函数是由：开发者创建的")]),v._v(" "),a("li",[v._v("默认构造函数是由：编译器生成的")])])]),v._v(" "),a("li",[v._v("创建方式上不同:\n"),a("ul",[a("li",[v._v("开发者在类中显示声明无参构造函数时，编译器不会生产默认构造函数")]),v._v(" "),a("li",[v._v("默认构造函数只能在类中没有显式声明构造函数的情况下，由编译器生成")])])]),v._v(" "),a("li",[v._v("创建目的上不同：\n"),a("ul",[a("li",[v._v("开发者在类中声明无参构造函数，视为了对象进行初始化操作")]),v._v(" "),a("li",[v._v("编译器生成默认构造函数，是为了在 JVM进行类加载时，能够顺利验证父类的数据信息")])])])]),v._v(" "),a("p",[v._v("类中 构造函数的执行顺序：")]),v._v(" "),a("p",[v._v("会先执行实例化成员变量的初始化表达式，然后在调用自己的构造函数")]),v._v(" "),a("blockquote",[a("p",[v._v("其他知识点：")]),v._v(" "),a("p",[v._v("Java对象的创建过程 & 构造函数的创建过程： https://segmentfault.com/a/1190000021944895")])]),v._v(" "),a("h2",{attrs:{id:"类变量、成员变量、局部变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类变量、成员变量、局部变量"}},[v._v("#")]),v._v(" 类变量、成员变量、局部变量")]),v._v(" "),a("br"),v._v(" "),a("img",{attrs:{src:v.$withBase("/java/oop/variable.png"),alt:"foo"}})])}),[],!1,null,null,null);_.default=i.exports}}]);