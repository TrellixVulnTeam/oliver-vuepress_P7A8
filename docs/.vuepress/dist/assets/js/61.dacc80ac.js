(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{612:function(t,s,a){"use strict";a.r(s);var e=a(17),_=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("Redis 没有直接使用 "),a("code",[t._v("C语言")]),t._v(" 的字符串（仅仅使用在字符串字面量，等无需进行字符串修改的地方，比如打印日志）,  而是自己定义了 "),a("code",[t._v("(Simple Dynamic String) SDS")]),t._v("  简单动态字符串实")])]),t._v(" "),a("p",[a("strong",[t._v("基本结构")])]),t._v(" "),a("div",{staticClass:"language-C extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("sdshdr")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("       \n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 记录buf 数组中已使用字节的数量 等于SDS 所保存字符串的长度  ")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" len"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("     \n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 记录buf 数组中未使用字节的数量  ")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" free"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   \n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 字节数组,用于保存字符串  ")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" buf"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("img",{attrs:{src:t.$withBase("/middleware/redislearn/redis简单动态字符串.png"),alt:"foo"}}),t._v(" "),a("h3",{attrs:{id:"为什么要使用sds"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用sds"}},[t._v("#")]),t._v(" 为什么要使用SDS")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/middleware/redislearn/SDS与C的区别.png"),alt:"foo"}}),t._v(" "),a("p",[a("strong",[t._v("SDS遵循C字符串以空字符结尾的惯例, 字符串末尾以"),a("code",[t._v("\\0")])]),t._v(" 这样做的为了，SDS可以直接重用一部分C字符串函数库里的函数")]),t._v(" "),a("p",[t._v("那又是为什么直接使用 C字符串呢？ 我们可以进行以下分析")]),t._v(" "),a("h4",{attrs:{id:"_1-时间复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-时间复杂度"}},[t._v("#")]),t._v(" 1. 时间复杂度")]),t._v(" "),a("ul",[a("li",[t._v("C语言字符串: 每次获取字符长度，需要进行遍历计算，获取的时间复杂度为 O(n)")]),t._v(" "),a("li",[t._v("SDS：结构中已经存储了使用的字符串长度，获取的时间复杂度为 O(1)")])]),t._v(" "),a("h4",{attrs:{id:"_2-缓冲区溢出"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-缓冲区溢出"}},[t._v("#")]),t._v(" 2. 缓冲区溢出")]),t._v(" "),a("p",[t._v("原：")]),t._v(" "),a("ul",[a("li",[t._v("S1: redis")]),t._v(" "),a("li",[t._v("S2: MonogoDB")])]),t._v(" "),a("p",[t._v("将 S1 修改为：Redis Cluster  内容将溢出的S2")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/middleware/redislearn/字符串缓冲区溢出1.png"),alt:"foo"}}),t._v(" "),a("img",{attrs:{src:t.$withBase("/middleware/redislearn/字符串缓冲区溢出2.png"),alt:"foo"}}),t._v(" "),a("p",[a("strong",[t._v("内存中 C字符串的多个字符串是内存空间是相邻在一起的, 并没有多余的内存空间，如果程序员在修改字符串时，忘记给字符串重新分配内存空间，那么就会发生内存溢出")])]),t._v(" "),a("p",[a("strong",[t._v("Redis提供的SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性， 当API需要对SDS进行修改时,API会先检查SDS的空间是否满足条件,如果不满足的话,API会自动将空间扩容,然后才执行修改操作,")])]),t._v(" "),a("h4",{attrs:{id:"_3-内存重分配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-内存重分配"}},[t._v("#")]),t._v(" 3.内存重分配")]),t._v(" "),a("p",[t._v("由于C语言字符串，修改时：")]),t._v(" "),a("ul",[a("li",[t._v("当修改字符 大于 原字符会进行扩容")]),t._v(" "),a("li",[t._v("当修改字符 小于 原字符会进行空间释放")])]),t._v(" "),a("blockquote",[a("p",[t._v("Redis 当做 缓存的一种存储，可能存在大量的对数据进行编辑，如果每次都要进行内存分配，会消耗大量的性能")])]),t._v(" "),a("p",[t._v("所以 Redis 进行了两点优化："),a("code",[t._v("空间预分配")]),t._v(" 和 "),a("code",[t._v("惰性释放空间")])]),t._v(" "),a("p",[a("strong",[t._v("空间预分配")])]),t._v(" "),a("blockquote",[a("p",[t._v("SDS进行空间扩展的时候,程序 "),a("strong",[t._v("不仅会为SDS分配修改所必须要的空间")]),t._v(" , "),a("strong",[t._v("还会为SDS分配额外的未使用空间")])])]),t._v(" "),a("ul",[a("li",[t._v("当字符串在长度小于 1M 之前, 扩容空间采用加倍策略 （即：字符串长度（len）分配多少，空闲长度（free）也分配多少）")]),t._v(" "),a("li",[t._v("当字符串在长度大于1M: 为了避免加倍后的空闲空间过大而导致浪费,每次扩容只会多分配 1M 大小的空闲空间")])]),t._v(" "),a("p",[a("strong",[t._v("惰性删除")])]),t._v(" "),a("blockquote",[a("p",[t._v("当 SDS 删除部分字符时，并不会释放出相应的字节空间，而是将自己增加到 "),a("code",[t._v("free空间")]),t._v(" 。等待将来对SDS修改时使用")])]),t._v(" "),a("p",[t._v("如果就要回收空间空间： SDS也提供了相应的API,让我们可以在有需要时,真正地释放SDS的未使用空间,所以不用担心惰性空间释放策略会造成内存浪费")]),t._v(" "),a("h4",{attrs:{id:"二进制安全"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二进制安全"}},[t._v("#")]),t._v(" 二进制安全")]),t._v(" "),a("ul",[a("li",[t._v("C语言字符串: 只支持存储纯文本数据，不支持存储二进制数据")]),t._v(" "),a("li",[t._v("SDS： 支持字符串、二进制编码")])])])}),[],!1,null,null,null);s.default=_.exports}}]);