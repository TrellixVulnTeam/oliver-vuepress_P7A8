(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{594:function(e,r,a){"use strict";a.r(r);var t=a(17),o=Object(t.a)({},(function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"集群架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集群架构"}},[e._v("#")]),e._v(" 集群架构")]),e._v(" "),a("img",{attrs:{src:e.$withBase("/middleware/kafka/kafka架构图.png"),alt:"foo"}}),e._v(" "),a("h3",{attrs:{id:"zookeeper"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper"}},[e._v("#")]),e._v(" Zookeeper")]),e._v(" "),a("blockquote",[a("p",[e._v("Kafka主要使用ZooKeeper来保存它的元数据、监控Broker和分区的存活状态，并利用ZooKeeper来进行选举")])]),e._v(" "),a("h3",{attrs:{id:"proudcuer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proudcuer"}},[e._v("#")]),e._v(" Proudcuer")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("生产者")]),e._v("  负责生产消息，将消费推送到 Broker 中")])]),e._v(" "),a("p",[a("RouterLink",{attrs:{to:"/articles/middleware/kafka/producer.html"}},[e._v("详细介绍")])],1),e._v(" "),a("h3",{attrs:{id:"consumer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consumer"}},[e._v("#")]),e._v(" Consumer")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("消费者")]),e._v(" 负责消费 "),a("code",[e._v("Broker")]),e._v(" 中的消息，与其他MQ不同 ，kafka 使用的 "),a("code",[e._v("pull")]),e._v(" 拉取模式")])]),e._v(" "),a("p",[a("strong",[e._v("消费者组（Consumer group）")])]),e._v(" "),a("p",[e._v("设置了同一个 "),a("code",[e._v("broker.id")]),e._v(" 的 消费者 认为是在同一个消费组中的\n消费者组 可以确保 一个主题的一个分区 只能被一个消费者 去进行消费")]),e._v(" "),a("h3",{attrs:{id:"broker"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#broker"}},[e._v("#")]),e._v(" Broker")]),e._v(" "),a("blockquote",[a("p",[e._v("一个kafka独立的服务器称为 Broker，集群中的一个 Broker ，可能会存在一个 或多个 topic")])]),e._v(" "),a("p",[a("RouterLink",{attrs:{to:"/articles/middleware/kafka/consumer.html"}},[e._v("详细介绍")])],1),e._v(" "),a("h3",{attrs:{id:"topic"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#topic"}},[e._v("#")]),e._v(" Topic")]),e._v(" "),a("blockquote",[a("p",[e._v("kafka 中将消息 以 "),a("code",[e._v("主题")]),e._v(" 进行分类。")]),e._v(" "),a("p",[e._v("主题是逻辑上的概念， 物理上:  不同 tpoic 的数据时分开存储")])]),e._v(" "),a("h3",{attrs:{id:"partition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#partition"}},[e._v("#")]),e._v(" Partition")]),e._v(" "),a("blockquote",[a("p",[e._v("主题可以被分为若干个分区，一个分区就是一个提交日志（即一个分区一个log文件），通过分区可以提高kafka并发消费能力")])]),e._v(" "),a("p",[e._v("每个分区都会有一个 "),a("code",[e._v("offset")]),e._v(" 标识 分区的偏移量。从而保证 "),a("strong",[e._v("分区内的消费顺序性")])]),e._v(" "),a("p",[e._v("由于 每个分区各自维护 各自的 "),a("code",[e._v("offset")]),e._v(",  并不是 一个主题共享维护一个 "),a("code",[e._v("offset")]),e._v(" ， 所以 kafka 只能维护 "),a("strong",[e._v("分区有序而不是主题有序")])]),e._v(" "),a("h3",{attrs:{id:"replica"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#replica"}},[e._v("#")]),e._v(" Replica")]),e._v(" "),a("blockquote",[a("p",[e._v("副本： kafka 提供了 分区副本机制，为每个分区，提供多个备份副本，提供了高可用性")])]),e._v(" "),a("ul",[a("li",[e._v("Leader副本： 对外提供服务的分区")]),e._v(" "),a("li",[e._v("Follower 副本： 不对外提供服务，只用作 Leader的备份，当 Leader奔溃时，Follower 可以切换成Leader副本")])]),e._v(" "),a("h2",{attrs:{id:"可用的-follower-副本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可用的-follower-副本"}},[e._v("#")]),e._v(" 可用的 Follower 副本")]),e._v(" "),a("p",[e._v("follower 副本消息同步的过程中， 很多时候会存在一定的消息滞后")]),e._v(" "),a("p",[e._v("由于：")]),e._v(" "),a("ul",[a("li",[e._v("为了保证性能：没有会用 同步操作")]),e._v(" "),a("li",[e._v("为了防止数据丢失：没有使用异步操作，只要Leader写入就认为操作")])]),e._v(" "),a("p",[e._v("而是使用了 ISR的 方式 有效地权衡了数据可靠性和性能之间的关系。")]),e._v(" "),a("p",[a("strong",[e._v("副本通称")])]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("AR")]),e._v(": 分区中的所有副本 （AR = ISR + OSR）")]),e._v(" "),a("li",[a("strong",[e._v("ISR")]),e._v(": 与 Leader副本保持一定同步的副本")]),e._v(" "),a("li",[a("strong",[e._v("OSR")]),e._v(":  与 Leader副本同步滞后过多的副本")])]),e._v(" "),a("p",[a("strong",[e._v("只有在ISR中的 Follower 副本 才能在，Leader宕机时，参与Leader选举")])]),e._v(" "),a("p",[a("strong",[e._v("OSR中的 Follower 副本当，同步数据 追上 Leader，则会重新回到 ISR集合中")])]),e._v(" "),a("p",[a("strong",[e._v("判断条件")])]),e._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 配置 ISR判断参数")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("## 默认为10S, 理解为：在该时间段内，Follower 副本存在一次 与 Leader 副本 同步 数据一致的情况")]),e._v("\nreplica.lag.time.max.ms\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("## （0.9版本之后移除配置） 允许 follower 副本落后 leader 副本的消息数量，超过这个数量后，follower 会被踢出 ISR  ")]),e._v("\nreplica.lag.max.messages \n")])])]),a("h2",{attrs:{id:"可见的消息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可见的消息"}},[e._v("#")]),e._v(" 可见的消息")]),e._v(" "),a("img",{attrs:{src:e.$withBase("/middleware/kafka/kafka可见消息.png"),alt:"foo"}}),e._v(" "),a("ul",[a("li",[a("strong",[e._v("HW(高水位)")]),e._v(": 取 follower 副本中 最小的 LEO")]),e._v(" "),a("li",[a("strong",[e._v("LEO")]),e._v(": 标识为：日志将要写入消息的 offset")])]),e._v(" "),a("p",[a("strong",[e._v("对于 "),a("code",[e._v("Conusmer")]),e._v(" 来说 只能 pull 到 HW 之前的数据")])])])}),[],!1,null,null,null);r.default=o.exports}}]);