(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{530:function(v,_,a){"use strict";a.r(_);var s=a(9),t=Object(s.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h2",{attrs:{id:"类的加载含义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类的加载含义"}},[v._v("#")]),v._v(" 类的加载含义")]),v._v(" "),a("p",[v._v("类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。")]),v._v(" "),a("h2",{attrs:{id:"类的加载过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类的加载过程"}},[v._v("#")]),v._v(" 类的加载过程")]),v._v(" "),a("p",[v._v("类的加载过程包含了 加载、连接、初始化、使用、销毁 五个阶段。其中 连接 中 包含了 （验证、准备、解析）")]),v._v(" "),a("img",{attrs:{src:v.$withBase("/java/lifeCycle.png"),alt:"foo"}}),v._v(" "),a("h3",{attrs:{id:"每个环境具体完成的了那些功能？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#每个环境具体完成的了那些功能？"}},[v._v("#")]),v._v(" 每个环境具体完成的了那些功能？")]),v._v(" "),a("h4",{attrs:{id:"加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#加载"}},[v._v("#")]),v._v(" 加载")]),v._v(" "),a("p",[v._v("加载阶段完成的三件事情：")]),v._v(" "),a("ul",[a("li",[v._v("通过一个类的全限定名来获取定义此类的二进制字节流")]),v._v(" "),a("li",[v._v("将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构")]),v._v(" "),a("li",[v._v("在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口")])]),v._v(" "),a("h4",{attrs:{id:"连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#连接"}},[v._v("#")]),v._v(" 连接")]),v._v(" "),a("p",[v._v("连接中 主要进行了 三大流程 验证 -> 准备 —> 解析")]),v._v(" "),a("h4",{attrs:{id:"验证"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#验证"}},[v._v("#")]),v._v(" 验证")]),v._v(" "),a("blockquote",[a("p",[v._v("目的是为了确保 class文件的字节流包含的信息是否符合当前虚拟机的药企，并且不会危害虚拟机的安全")])]),v._v(" "),a("p",[v._v("具体的验证方式：")]),v._v(" "),a("ul",[a("li",[v._v("文件格式验证")]),v._v(" "),a("li",[v._v("元数据验证")]),v._v(" "),a("li",[v._v("字节码验证")]),v._v(" "),a("li",[v._v("符号引用验证")])]),v._v(" "),a("h4",{attrs:{id:"准备"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#准备"}},[v._v("#")]),v._v(" 准备")]),v._v(" "),a("blockquote",[a("p",[v._v("为变量分配内存并设置变量的初始值，这些变量使用的内存都将在方法去中进行分配")])]),v._v(" "),a("p",[v._v("类型的默认值：")]),v._v(" "),a("ul",[a("li",[v._v("int: 0")]),v._v(" "),a("li",[v._v("long: 0L")]),v._v(" "),a("li",[v._v("short: (short) 0")]),v._v(" "),a("li",[v._v("char: '\\u0000'")]),v._v(" "),a("li",[v._v("byte: (byte) 0")]),v._v(" "),a("li",[v._v("boolean: false")]),v._v(" "),a("li",[v._v("float: 0.0f")]),v._v(" "),a("li",[v._v("double: 0.0d")]),v._v(" "),a("li",[v._v("reference: null")])]),v._v(" "),a("p",[v._v("reference类型 包含了 类类型，数组类型 和接口类型")]),v._v(" "),a("h4",{attrs:{id:"解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解析"}},[v._v("#")]),v._v(" 解析")]),v._v(" "),a("blockquote",[a("p",[v._v("解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程\n即 类中的 符号引用 转换为 直接引用")])]),v._v(" "),a("ul",[a("li",[v._v("符号引用（SymbolicReferences）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。")]),v._v(" "),a("li",[v._v("直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。")])]),v._v(" "),a("p",[v._v("如果有了直接引用，那么引用的目标一定是已经存在于内存中。")]),v._v(" "),a("p",[v._v("解析对象包括：")]),v._v(" "),a("ul",[a("li",[v._v("类 和 接口的解析")]),v._v(" "),a("li",[v._v("字段解析")]),v._v(" "),a("li",[v._v("类方法 和 接口方法解析")])]),v._v(" "),a("h4",{attrs:{id:"初始化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[v._v("#")]),v._v(" 初始化")]),v._v(" "),a("blockquote",[a("p",[v._v("为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化")])]),v._v(" "),a("p",[v._v("初始化的时机：")]),v._v(" "),a("ul",[a("li",[v._v("创建类的实例，也就是 "),a("code",[v._v("new")]),v._v(" 的方式")]),v._v(" "),a("li",[v._v("反射对类进行调用时，反射（如Class.forName(“com.shengsiyuan.Test”)）")]),v._v(" "),a("li",[v._v("java 虚拟机启动时，会对启动的主类进行实例化")]),v._v(" "),a("li",[v._v("调用类的静态方法")]),v._v(" "),a("li",[v._v("初始化某个类的子类，则其父类也会初始化")]),v._v(" "),a("li",[v._v("访问某个类或接口的静态变量，或者对改静态变量赋值")])]),v._v(" "),a("p",[v._v("不会被初始化的例子：")]),v._v(" "),a("ul",[a("li",[v._v("调用类的常量 （常量在编译阶段就存入调用类的常量池中了）")]),v._v(" "),a("li",[v._v("通过数组定义来引用类")]),v._v(" "),a("li",[v._v("通过子类引用父类的静态字段、子类不会被初始化")])]),v._v(" "),a("h4",{attrs:{id:"使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[v._v("#")]),v._v(" 使用")]),v._v(" "),a("blockquote",[a("p",[v._v("嘿嘿嘿 我相信你是知道的！")])]),v._v(" "),a("h4",{attrs:{id:"卸载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#卸载"}},[v._v("#")]),v._v(" 卸载")]),v._v(" "),a("blockquote",[a("p",[v._v("除非使用自定义类加载器，或者应用关闭，否则类时不会卸载的，也就是说通常情况下类加载过程 就只会走一遍")])]),v._v(" "),a("p",[v._v("类的卸载要同事满足一下3种情况，可以稍微了解一下：")]),v._v(" "),a("ul",[a("li",[v._v("该类的所有实例以及被回收，java堆中不存在该类的任何实例")]),v._v(" "),a("li",[v._v("加载该类的 "),a("code",[v._v("ClassLoader")]),v._v(" 被回收")]),v._v(" "),a("li",[v._v("该类对应的  "),a("code",[v._v("java.lang.Class")]),v._v(" 对象以及没有任何地方被引用，并且无法通过反射访问该类方法")])]),v._v(" "),a("h3",{attrs:{id:"类的加载器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类的加载器"}},[v._v("#")]),v._v(" 类的加载器")]),v._v(" "),a("blockquote",[a("p",[v._v("JVM的类加载是通过ClassLoader及其子类来完成的，虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，JVM提供了3种类加载器：")])]),v._v(" "),a("h4",{attrs:{id:"类加载的三种方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类加载的三种方式"}},[v._v("#")]),v._v(" 类加载的三种方式")]),v._v(" "),a("ul",[a("li",[v._v("启动类加载器（Bootstrap ClassLoader）\n"),a("ul",[a("li",[v._v("负责加载存放在 "),a("code",[v._v("JAVA_HOME\\jre\\lib")]),v._v(" 目录，或 被 "),a("code",[v._v("-X bootclasspath")]),v._v(" 参数指定的路径中的，并且能被虚拟机识别的类库")])])]),v._v(" "),a("li",[v._v("扩展类加载器：\n"),a("ul",[a("li",[v._v("该加载器由 "),a("code",[v._v("sun.misc.Launcher$ExtClassLoader")]),v._v(" 实现, 它负责加载 "),a("code",[v._v("<JAVA_HOME>\\jre\\lib\\ext")]),v._v(" 目录中的文件，或者被 "),a("code",[v._v("java.ext.dirs")]),v._v(" 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器，java中的实现类 "),a("code",[v._v("ExtClassLoader")])])])]),v._v(" "),a("li",[v._v("应用程序类加载器：该类加载器由 "),a("code",[v._v("sun.misc.Launcher$AppClassLoader")]),v._v(" 来实现，它负责加载用户类路径（ClassPath）所指定的类")])]),v._v(" "),a("p",[a("strong",[v._v("我们也可以通过继承 "),a("code",[v._v("java.lang.ClassLoader")]),v._v(" 实现自定义的类加载器")])]),v._v(" "),a("blockquote",[a("p",[v._v("ps: 有兴趣的 可以研究一下 如何进行写一个自定义的类加载器")])]),v._v(" "),a("h3",{attrs:{id:"双亲委派模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派模式"}},[v._v("#")]),v._v(" 双亲委派模式")]),v._v(" "),a("blockquote",[a("p",[v._v("通俗的讲，就是某个特定的类加载器在接收到加载类的请求时，首先将加载任务托付给父类加载器，一次递归，如果父类加载器可以完成类加载任务，就成功返回，只有父类加载器无法完成此任务时，才自己去加载")])]),v._v(" "),a("img",{attrs:{src:v.$withBase("/java/classLoader20200907.jpg"),alt:"foo"}}),v._v(" "),a("p",[v._v("各个类加载器之间的层次关系被称为类加载器的双亲委派模型。该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）。")])])}),[],!1,null,null,null);_.default=t.exports}}]);