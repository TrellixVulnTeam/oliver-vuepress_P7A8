---
isTimeLine: true
sidebar: true
isComment: false
title: Redis对象
date: 2022-4-20
tags:
- Redis
---

> Redis系统中包含 字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象。也是我们一直使用的对象，而每种对象一种或多种数据结构实现。

<img :src="$withBase('/middleware/redislearn/Reids对象与数据结构关系图.png')" alt="foo">

<center><b>整体对象数据结构图</b></center>

## RedisObject

```C
struct redisObject {     
  // 类型    
  unsigned type:4; 
  // 编码   
  unsigned encoding:4;     
  // 指向底层实现数据结构的指针   
    void *ptr;  
} robj;
```

<center>基本的类型</center>

<img :src="$withBase('/middleware/redislearn/Redis对象类型.png')" alt="foo">

<img :src="$withBase('/middleware/redislearn/Redis对象类型编码.png')" alt="foo">



### StringObject

----

> 字符串对象的编码可以是int、raw或者embstr

#### 底层编码的选择策略

| 编码   | 使用条件                     | 编码转换                                                     |
| ------ | ---------------------------- | ------------------------------------------------------------ |
| int    | 符串对象保存的是整数值       | 对象保存的不再是整数值,而是一个字符串值 会转换成 `raw`       |
| embstr | 字符串值的长度小于等于32字节 | embstr编码的字符串对象实际上是只读的。当我们对embstr 编码的字符串对象执行任何修改命令时,程序会先将对象的编码从embstr转换成raw, |
| raw    | 字符串值的长度大于32字节     |                                                              |

<img :src="$withBase('/middleware/redislearn/StringObject.png')" alt="foo">



#### embstr 与 raw区别

> 两个编码格式同为 `SDS` 那又有什么区别呢？ 
>
> `embstr` 使用在较短的字符串上 
>
> `raw`  使用在较长的字符串上

**embstr使用在较短字符串的优势？**

1. `embstr` 内存分配次数 比 raw的两次分配少一次。embstr 会直接申请两个连续的内存区域
2. 释放内存时，也只需要调用一次内释放
3. 因为`embstr`编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用CPU缓存提升性能。



#### 常用场景

1. 基本的缓存
2. 计数器\限速器\分布式ID
   1. 计数器：点赞数、评论数、分享数、作品数
   2. 限速器：接口访问频率限制、短信验证码使用频率限制
   3. 分布式ID: 通过Redis生成 唯一的订单号、序列号
3. 分布式session
4. 二进制存储 （文件、图片、音频）

### ListObject

----

> 底层实现：`ziplist`、`linkedList` 、`quickList`

#### 底层编码的选择策略

**Redis3.2之前**

| 编码       | 使用条件                                                     | 其他                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ziplist    | 1. 列表对象保存的所有字符串元素的长度都小于64字节;  <br />2. 列表对象保存的元素数量小于512个; | 可以修改ziplist的长度 和元素设置<br />list-max-ziplist-value  和<br /> list-max-ziplist-entries |
| linkedList | 不能满足上述两个条件的中的任何一个                           |                                                              |

**Redis3.2之后**

使用 quickList 代替 ziplist  和 linkedList



#### 常用场景

- 消息队列
- 各种列表



**关于列表的使用场景可参考以下几个命令组合：**

- lpush+lpop=Stack（栈）
- lpush+rpop=Queue（队列）
- lpush+ltrim=Capped Collection（有限集合）
- lpush+brpop=Message Queue（消息队列）

### HashObject

----

> 哈希对象，是一种键值对的形势，底层使用 `ziplist`  和 `hashtable` 实现

#### 底层编码的选择策略

| 编码      | 使用条件                                                     | 其他                                                         |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Ziplist   | 1. 哈希对象保存的所有的键 和 值的字符串长度都小于64字节;  <br />2. 哈希对象保存的键值对元素数量小于512个; | 可以修改ziplist的长度 和元素设置<br />hash-max-ziplist-value  和<br /> hash-max-ziplist-entries |
| hashtable | 不能满足上述两个条件的中的任何一个                           |                                                              |

#### 常见场景

1. 存储信息当做表使用：商品、课程、等
2. 暂存数据：填写表单、购物车
3. 计数器：用过一年，一个月，统计访问量

### SetObject

> 集合类型 (Set) 是一个无序并唯一的键值集合。它的存储顺序不会按照插入的先后顺序进行存储
>
> 集合对象 编码底层使用 `intset`、`hashtable(dict)`

 #### 与列表的区别

- 列表可以存储重复元素，集合只能存储非重复元素
- 列表是按照元素的先后顺序存储元素的，而集合则是无序方式存储元素的

#### 底层编码的选择策略

| 编码            | 使用条件                                                     | 编码转换                                                     | 其他                                    |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------- |
| intset          | 对象中都是整数时，使用整数集合                               | 集合对象保存的所有元素都是整数值; <br />集合对象保存的元素数量不超过512个 | 可以设置元素大小：setmax-intset-entries |
| Hashtable(dict) | 字典的每个键都是一个字符串对象,<br />每个字符串对象包含了一个集合元素, 而字典的值则全部被设置为NULL |                                                              |                                         |

#### 常用场景

- 标签系统：
- 抽奖系统：SPOP(随机移除并返回集合中一个或多个元素  和 SRANDMEMBER(随机返回集合中一个或多个元素）



### ZSetObject

> 编码底层使用 `ziplist）`  和 `skiplist` + `dict`

#### 底层编码的选择策略

| 编码                | 编码转换                                                     | 其他                                                         |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ziplist             | 有序集合保存的元素数量小于128个; <br />有序集合保存的所有元素成员的长度都小于64字节 | 可以对其参数进行修改：<br />zset-max-ziplist-entries<br />zset-max-ziplist-value |
| `skiplist` + `dict` | 不能满足上述两个条件的中的任何一个                           |                                                              |

**为什么有序集合需要同时使用跳跃表和字典来实现?**

1. 通过 dict 实现 查找成员 时间复杂度O(0)
2. 通过 跳跃表 实现 O(logN) 的 范围查询效率



**那元素存储两份数据会浪费空间吗？**

实际中 字典 和 跳跃表会共享元素的成员 和 分值



#### 常用场景

- 排行榜系统
- 集合排序



### 其他

---

#### 对象内存的回收

> 由于 `C语言` 不具备自动内存回收的功能，所以 Redis自身实现了一个 `引用计数器` 。
>
> 通过 对象的 引用计数信息 可以自动释放对象 并 进行内存回收

**redisObject**  对象中 使用 `refcount` 作为计数值

```C
struct redisObject {    
    // 引用计数    
  int refcount;     // ...
} robj
```

#### 对象数据共享

> 对象的引用计数属性还带有对象共享的作用

共享步骤：

1. 将数据库键的值指针指向一个现有的值对象; 

1. 将被共享的值对象的引用计数增一。