---
isTimeLine: true
sidebar: true
isComment: false
title: Redis 客户端 & 服务器
date: 2022-4-20
tags:
- Redis
---

> Redis 服务器 是典型的一对多服务器程序，通过 使用 I/O 多路复用技术 实现了 事件处理
>
> Redis客户端：每个与 服务端 需要建立连接的客户端，服务端都会为其建立响应的 `redis.h/redisClient结构`  用于保存客户端信息

## 客户端

<img :src="$withBase('/middleware/redislearn/image-20220403164219355.png')" alt="foo">

- Clients属性：是一个链表，存储这所有连接的服务。每新增一个客户端 都会向 链表尾部添加



**伪客户端**

- Lua伪客户端：服务器初始化后，就会创建专门执行 Lua命令的客户端，只有服务器关闭Lua伪客户端才会被关闭

- AOF伪客户端：服务器启动时，如果存在AOF文件导入，则会创建一个伪客户端，并在载入完数据后，关闭伪客户端



**关闭客户端的方式**

- 客户端进程退出或者被杀死
- 客户端向服务器发送了带有不符合协议格式的命令请求
- 客户端成为了 `CLIENT KILL命令` 的目标
- 服务器设置了`timeout配置` 选项, 当客户端存在 空转时间(空闲为请求服务器的诗句) 超过 timeout设置的值
- 客户端 命令请求的大小 超过 输入缓存区 限制大小 1G   
- 命令回复的大小 超过 输出缓冲区大小 (**硬性限制** )
- 命令回复的大小 超过  软性限制所设置的大小,但还没超过硬性限制 (**软性限制**)。
  - 在指定的时间内 不在超过 软性限制 则 客户端不会关闭 



### 客户端属性

```c
typedef struct redisClient {    
    int fd;     				 // 客户端标识符 
    robj *name；  			  // 名字
    int flags;					 // 记录客户端角色
    sds querybuf;  			 // 输入缓存区
    robj **argv;				 // 命令与命令参数数组
    int argc;						 // 命令参数数组元素个数
    redisCommand *cmd    // 命令 对应的操作函数
    char buf[EDIS_REPLY_CHUNK_BYTES];				// 输出缓冲区 - 固定大小缓冲区
    int bufpos;															// 输出缓冲区 - 元素个数
    list *reply;														// 输出缓冲区 - 可变大小缓冲区
    int authenticated;											// 身份验证
    time_t ctime;														// 创建客户端的时间
    time_t lastinteraction;									// 最后一次和服务器交互的时间
    time_t obuf_soft_limit_reached_t;				// 第一次到达软性限制的时间
```

<img :src="$withBase('/middleware/redislearn/image-20220403193232214.png')" alt="foo">



### 输入缓冲区

> 输入缓冲区 保存客户端发送的命令

输入缓冲区  支持动态 缩小 或 扩大，但是最大内存不能超过 1G

### 输出缓冲区

> 每个客户端都有两个缓冲区： `固定缓冲区` 和 `可变大小缓冲区`

- 固定缓冲区(buf): 字符数组    
  - 保存长度比较小的回复、OK、简短的字符串、整数值、错误
- 可变大小缓冲区(reply): 链表
  - 非常长的字符串值

`buf`  数组默认使用 常量 `REDIS_REPLY_CHUNK_BYTES`  默认为：16*1024 = 16K



##  服务器

<img :src="$withBase('/middleware/redislearn/image-20220403222822821.png')" alt="foo">



**具体流程**

- 请求端
  - 用户 发送命令请求
  - 客户端将这个 命令请求转换成协议格式  将 通过与服务器的套接字（socket）发送命令请求给服务器 

- 服务端
  - 读取命令请求：
    - 读取 套接字中的协议格式的命令请求 ，将其保存到客户端状态的输入缓冲区中
    - 提起 命令请求中 命令 和 命令参数
    - 调用命令执行器,执行客户端指定的命令
      - 查找命令实现：
        - 他那个个 argv[0] 参数，寻找 命令表中对应的命令，将命令保存到 RedisClient 中 cmd 中 （忽略大小写 查找不受大小写影响）
      - 执行预备操作 （在真正执行前，做一下预处理，保证命令能正确、顺利的被执行）
        - 检查客户端 cmd 指针是否执行 null
        - 通过 RedisCommand结构的 arity 属性 判断 参数的个数是否符号命令要求
        - 检查客户端是否已经通过身份验证
        - 打开了maxmemory功能, 执行前会检查内存占用情况，并在需要的时候执行内存回收
        - 如果服务器上一次执行BGSAVE命令时出错,并且服务器打开了stop-writes-on-bgsave-error功能,而且服务器即将要执行的命令是一个写命令,
        - 如果客户端当前正在用SUBSCRIBE命令订阅频道,或者正在用PSUBSCRIBE命令订阅模式,那么服务器只会执行客户端发来的SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE四个命令
        - 如果服务器正在进行数据载入,那么客户端发送的命令必须带有l 标识(比如INFO、SHUTDOWN、PUBLISH等等)才会被服务器执行
        - 如果客户端正在执行事务,那么服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH四个命令,其他命令都会被放进事务队列中
        - 如果服务器打开了监视器功能,那么服务器会将要执行的命令和参数等信息发送给监视器。当完成了以上预备操作之后,服务器就可以开始真正执行命令了
      - 调用命令的实现函数 
        - （具体的执行操作，执行完成 会产生一个命令回复，保存在 客户端的输出缓冲区）
      - 执行后续工作
        - 慢查询日志
        - 更新 redisCommand结构的milliseconds属性,并将命令的redisCommand结构的calls计数器的值增一
        - 写入AOF缓冲区
        - 传播命令给从服务器
    - 命令回复发送给客户端
      - 当客户端 套接字为 可写状态时，将执行 回复处理器，将输出缓冲区的命令发送给客户端
      - 发送完毕后，清除输出缓冲区
      - 客户端接收并打印命令
        - 将 回复的内容，转换后打印给用户



### serverCron 函数

>  每隔 100 毫秒 执行一次，这个函数 负责管理服务器的资源

**ServerCron执行那些操作**

- 更新服务器时间缓存
- 更新LRU时钟

- **更新服务器内秒执行命令次数**
- 更新服务器内存峰值记录
  - 每次ServerCron函数执行时，都会进行计算  如果比原值大 则更新
- 处理SIGTERM信号
- 管理客户端资源
- 管理数据库资源
- 执行被延迟的BGREWRITEAOF
- 检查持久化操作的运行状态
- 将AOF缓冲区中的内容写入AOF文件
- 关闭异步客户端
- 增加cronloops计数器的值



###   初始化服务器

1. 初始化服务器状态： 即初始化 server变量操作
2. 载入服务器配置：载入用户的配置 和 配置文件
3. 初始化服务器数据结构：客户端连接、db数组、lua客户端、慢日志等
4. 还原数据库状态： 通过 AOF 或 RDB 还原数据
5. 执行事件循环:  用于监听事件
