---
isTimeLine: true
sidebar: true
isComment: false
title: Redis数据结构-简单动态字符串SDS
date: 2022-4-20
tags:
- Redis
---

> Redis 没有直接使用 `C语言` 的字符串（仅仅使用在字符串字面量，等无需进行字符串修改的地方，比如打印日志）,  而是自己定义了 `(Simple Dynamic String) SDS`  简单动态字符串实

**基本结构**

```C
struct sdshdr {       
  // 记录buf 数组中已使用字节的数量 等于SDS 所保存字符串的长度  
  int len;     
  // 记录buf 数组中未使用字节的数量  
  int free;   
  // 字节数组,用于保存字符串  
  char buf[]; 
};
```

<img :src="$withBase('/middleware/redislearn/redis简单动态字符串.png')" alt="foo">




### 为什么要使用SDS

<img :src="$withBase('/middleware/redislearn/SDS与C的区别.png')" alt="foo">

**SDS遵循C字符串以空字符结尾的惯例, 字符串末尾以`\0`** 这样做的为了，SDS可以直接重用一部分C字符串函数库里的函数

那又是为什么直接使用 C字符串呢？ 我们可以进行以下分析



#### 1. 时间复杂度

- C语言字符串: 每次获取字符长度，需要进行遍历计算，获取的时间复杂度为 O(n)
- SDS：结构中已经存储了使用的字符串长度，获取的时间复杂度为 O(1)



#### 2. 缓冲区溢出

原：

- S1: redis
- S2: MonogoDB

将 S1 修改为：Redis Cluster  内容将溢出的S2

<img :src="$withBase('/middleware/redislearn/字符串缓冲区溢出1.png')" alt="foo">


<img :src="$withBase('/middleware/redislearn/字符串缓冲区溢出2.png')" alt="foo">



**内存中 C字符串的多个字符串是内存空间是相邻在一起的, 并没有多余的内存空间，如果程序员在修改字符串时，忘记给字符串重新分配内存空间，那么就会发生内存溢出**


**Redis提供的SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性， 当API需要对SDS进行修改时,API会先检查SDS的空间是否满足条件,如果不满足的话,API会自动将空间扩容,然后才执行修改操作,**



#### 3.内存重分配

由于C语言字符串，修改时：

- 当修改字符 大于 原字符会进行扩容
- 当修改字符 小于 原字符会进行空间释放

>  Redis 当做 缓存的一种存储，可能存在大量的对数据进行编辑，如果每次都要进行内存分配，会消耗大量的性能

所以 Redis 进行了两点优化：`空间预分配` 和 `惰性释放空间`



**空间预分配**

> SDS进行空间扩展的时候,程序 **不仅会为SDS分配修改所必须要的空间** , **还会为SDS分配额外的未使用空间**

- 当字符串在长度小于 1M 之前, 扩容空间采用加倍策略 （即：字符串长度（len）分配多少，空闲长度（free）也分配多少）
- 当字符串在长度大于1M: 为了避免加倍后的空闲空间过大而导致浪费,每次扩容只会多分配 1M 大小的空闲空间



**惰性删除**

> 当 SDS 删除部分字符时，并不会释放出相应的字节空间，而是将自己增加到 `free空间` 。等待将来对SDS修改时使用

如果就要回收空间空间： SDS也提供了相应的API,让我们可以在有需要时,真正地释放SDS的未使用空间,所以不用担心惰性空间释放策略会造成内存浪费



#### 二进制安全

- C语言字符串: 只支持存储纯文本数据，不支持存储二进制数据
- SDS： 支持字符串、二进制编码
