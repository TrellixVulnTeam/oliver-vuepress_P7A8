---
isTimeLine: true
sidebar: true
isComment: false
title: Redis 缓存过期 和 淘汰策略
date: 2022-4-20
tags:
- Redis
---

## 缓存过期

> Redis 作为缓存使用，不断增加 Key ，则会出现 达到物理内存峰值后性能急剧下降，甚至奔溃。这就需要我们进行合理的分配 Redis 使用的 最大内存大小
>
> Redis 通过  `maxmemory`  参数进行配置， 默认为：0   不进行限制

**建议** 设置成 物理内存的 ` 3/4`  比较合适
**注** 当 设置 `maxmemory` 大小后：当内存趋近 `maxmemory` 时，通过缓存淘汰策略，从内存中删除对象

具体配置操作：

```c
# 在 redis.conf 中进行设置
maxmemory 1024mb
```

**设置缓存过期时间的方式**

- `EXPIRE<key><ttl>` 命令用于将键key的生存时间设置为ttl秒。
- `PEXPIRE<key><ttl>` 命令用于将键key的生存时间设置为ttl毫秒。
- `EXPIREAT<key><timestamp>` 命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。
- `PEXPIREAT<key><timestamp>` 命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。

**EXPIRE、PEXPIRE和EXPIREAT三个命令都会转换成PEXPIREAT**



### 过期时间的保存方式

**RedisDb**  结构中使用  `expries` 字典（保存 过期对象）

键：设置过期对象的指针

值：long型的过期时间 （一个毫秒精度的UNIX时间戳）

```
struct redisDb{
  dict *expires; 过期字典,保存着键的过期时间 
} redisDb;
```

<img :src="$withBase('/middleware/redislearn/redis缓存过期时间数据结构.png')" alt="foo">



### 过期键的的判定

- Key 是否在 过期字典中
- key设置的 时间戳 是否大于 当前时间，大于则未过期

### 过期删除策略

| 过期策略 | 分类           | 原理                                                         | 优点                                                         | 缺点                                                         |
| :------: | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定时删除 | 主动删除型策略 | 当设置完key的过期时间，同时设置一个定时器来进行对 key的过期删除操作 | 对内存最友好：过期key，立马被释放，不占用内存                | 对CPU不友好：在过期key 过多时，过多的定时器会占用CPU大量的资源 |
| 惰性删除 | 被动删除型策略 | 对过期key不主动删除，只有 key被访问时，会进行判断是否过期，过期则删除key | 对CPU最友好： 只有在取出key 的时候才进行检查，其他时候就算过期也不做任何操作 | 对内存不友好：如果大量过期key, 长时间不被访问，将一直占用内存空间，造成空间浪费  也算是一种 `内存泄漏` |
| 定期删除 | 主动删除型策略 | 每隔一段时间，进行检查并删除过期的key, 至于删除多少key,检查多少库 由算法决定 | 定期删除，限制了删除的时长和频率减少对CPU的影响，也又有定期删除的减少了 key过期造成的内存浪费 | 难以：确定删除操作执行的时长和频率:                          |



## 内存淘汰策略

### 配置内存淘汰策略

> 通过 redis.conf 进行配置 主动删除策略，默认是 `no-enviction` (不删除)
```c
maxmemory-policy allkeys-lru
```

**注**  默认的内存淘汰策略： `noenviction`



**淘汰策略类型**

- noenviction: 禁止内存淘汰，默认设置
- LRU
	- volatile-lru ： 从已设置过期时间的 数据集 中挑选最近最少使用的数据淘汰
	- allkeys-lru： 从所有的 数据集 中挑选最近最少使用的数据淘汰
- LFU
	- volatile-lfu： 从配置了过期时间的键中删除使用频率最少的键
	- allkeys-lfu： 从所有的键中删除使用频率最少的键
- random
	- volatile-random： 从已设置过期时间的 数据集 中 随机选择数据淘汰
	- allkeys-random： 从所有的 数据集 中 随机选择数据淘汰
- ttl
	- volatile-ttl： 从已设置过期的 数据集 中 挑选将要过期的数据淘汰


### LRU
> LRU (Least recently used) 最近最少使用，算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”

### LFU
> LFU (Least frequently used) 最不经常使用，如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。

- LRU:
	- 即长时间没有读取，或写，则会被移到链表尾部，进行删除
- LFU
	- 即 一段时间内使用频次最少的，进行删除，类似于范围区间内统计次数