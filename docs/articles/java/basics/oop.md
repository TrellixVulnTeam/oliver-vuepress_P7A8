---
isTimeLine: true
sidebar: true
isComment: false
title: 面向对象
date: 2020-11-07
tags:
- Java
--- 
## 什么是面向对象

### 什么是面向过程 ?

>  自顶而下的编程模式

就是说：将一个功能点 一步接一步的调用函数实现，并没后做相对应的抽象


### 什么是面向对象？

> 将事务高度抽象化的编程模式

就是说：将一个功能点中的每个步进行相对应的抽象形成不同的对象，通过不同对象之间的调用，或组合来完成功能


### 面向对象的三大特征

- 封装
- 继承
- 多态

> 具体含义可自行百度



### 面向对象的五大基本原则：

#### 单一职责原则（Single-Responsibility Principle）

- 核心思想：一个类，最好只做一件事情  并且 仅有一个引起它变化的原因
- 简单的理解 ：一个对象的功能要单一，可以理解为 低耦合、高内聚



#### 开放封闭原则（Open-Closed principle）

- 核心思想: 软件实体应该是可扩展，而不可修改的
  - 对于扩展是开放的
  - 对于修改是封闭的
- 扩展开放：
  - 因为需求总是在变化的，我们可以对现有代码进行扩展，在变化时我们可以通过继承或多态机制，来改变固有行为，实现新的扩展方法
- 修改封闭：
  - 类一但时设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。
  - 核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的



#### Liskov替换原则（Liskov-Substitution Principle）

- 子类型必须能够替换掉它们的父类型。简单地说，这是因为子类型继承了父类，所以子类可以以父类的身份出现。



#### 依赖倒置原则（Dependecy-Inversion Principle）

- 核心思想：抽象不应该依赖写，细节应该依赖于抽象
- 简单的理解：我们要针对接口编程，而不要针对实现编程
  - 高层模块不应该依赖底层模块，两个都应该依赖抽象
    - 缺点：高度模块太依赖底层模块，耦合太紧密。底层模块发送变化会影响到高层模块
  - 抽象不用管依赖具体（细节），具体 （细节） 应该依赖抽象
    - 有点：修改底层不会影响到高层模块，减小了他们之间的耦合度，增强系统的稳定性



#### 接口隔离原则（Interface-Segregation Principle）

- 核心思想：使用多个小的专门的接口，而不要使用一个大的总接口
- 原则体现：接口应该是内聚的，应该避免 `胖`接口。胖接口可能有很多我们用不到的方法，不要强迫依赖不用的方法，这是一种接口污染
- 通俗的理解：不要强迫客户使用他们不想用的商品
- 解决方案：
  - 委任分离：通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销
  - 多重继承分离接口：通过集成多个单一小接口，来解决继承的大接口



## 封装、继承、多态

###  什么是多态

> 同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果
>
> 多态应该是一种运行期的状态

多态的必要条件：

- 类要有继承 或者接口实现
- 子类要重写父类的方法
- 父类的引用执行子类的对象


## 方法重写 与 重载

### 重写

<br>

<img :src="$withBase('/java/oop/overriding.png')" alt="foo">

###  重载

<br>

<img :src="$withBase('/java/oop/overloading.png')" alt="foo">

>  其他相关：
>
> https://blog.csdn.net/carson_ho/article/details/81502540
>
> https://www.cnblogs.com/constantwang/p/11141566.html



### Java的继承 与 实现

> Java 中 
>
> 继承的根本原因是要 `复用`
>
> 实现的根本原因是要 `定义一个标准`

继承使用 `extends` 关键字实现

实现使用 `implemenets` 实现



## Java的构造函数 与 默认构造函数

构造函数：主要用来在创建对象时初始化对象，一般会跟new 运算符一起使用，给对象成员变量赋初始值

构造函数的特点：

- 构造函数的 *名称必须与类名相同*， 并且大小写铭感
- 构造函数 没有返回值、也不能用 void修饰 （如果构造函数 加上了返回值，就会变为普通函数）
- 一个类可以用有多个构造方法，如果没有定义构造方法，编译器会自动创建一个无参数且方法体为空的默认构造函数
- 构造方法可以进行 *重载* 



显示声明的无惨构造函数 和 默认构造函数的区别

- 创建主体不同：
  - 无惨构造函数是由：开发者创建的
  - 默认构造函数是由：编译器生成的
- 创建方式上不同:
  - 开发者在类中显示声明无参构造函数时，编译器不会生产默认构造函数
  - 默认构造函数只能在类中没有显式声明构造函数的情况下，由编译器生成
- 创建目的上不同：
  - 开发者在类中声明无参构造函数，视为了对象进行初始化操作
  - 编译器生成默认构造函数，是为了在 JVM进行类加载时，能够顺利验证父类的数据信息



类中 构造函数的执行顺序：

会先执行实例化成员变量的初始化表达式，然后在调用自己的构造函数



> 其他知识点：
>
> Java对象的创建过程 & 构造函数的创建过程： https://segmentfault.com/a/1190000021944895



## 类变量、成员变量、局部变量

<br>

<img :src="$withBase('/java/oop/variable.png')" alt="foo">

